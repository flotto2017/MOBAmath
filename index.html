<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Math ROV: Stable Multiplayer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    
    <style>
        body { overscroll-behavior: none; user-select: none; -webkit-user-select: none; overflow: hidden; font-family: sans-serif; background-color: #020617; }
        #game-area { position: relative; overflow: hidden; background-color: #052e16; cursor: crosshair; touch-action: none; }
        #ui-panel { height: 260px; background-color: #0f172a; border-top: 4px solid #1e293b; display: flex; box-shadow: 0 -10px 30px rgba(0,0,0,0.8); z-index: 50; }
        .damage-text { position: absolute; color: white; font-weight: 900; font-size: 24px; pointer-events: none; animation: floatPop 0.6s cubic-bezier(0.18, 0.89, 0.32, 1.28) forwards; text-shadow: 2px 2px 0px #000; z-index: 100; -webkit-text-stroke: 1.5px black; }
        @media (min-width: 768px) { .damage-text { font-size: 32px; } }
        @keyframes floatPop { 0% { transform: translateY(0) scale(0.5); opacity: 0; } 20% { transform: translateY(-10px) scale(1.2); opacity: 1; } 100% { transform: translateY(-50px) scale(1); opacity: 0; } }
        .overlay-screen { position: absolute; inset: 0; z-index: 100; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .hidden { display: none !important; }
        /* Shop Card Hover */
        .shop-card:active { transform: scale(0.98); }
    </style>

    <!-- FIREBASE MODULE (Isolated) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, updateDoc, collection, getDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyDSRWRHZ0tSWBolCjtzcz9SHtozIimqXNQ",
            authDomain: "mobamath-d7343.firebaseapp.com",
            projectId: "mobamath-d7343",
            storageBucket: "mobamath-d7343.firebasestorage.app",
            messagingSenderId: "1073634282918",
            appId: "1:1073634282918:web:576aab55ae51ed02a11367",
            measurementId: "G-WVF93G5ZC8"
        };

        const appId = 'math-moba-v1';
        let db, auth, user, roomId;
        let isHost = false;
        let unsubscribeRoom = null;

        // Initialize Firebase safely
        try {
            const app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            signInAnonymously(auth).catch(e => console.warn("Offline Mode:", e));
            onAuthStateChanged(auth, (u) => { 
                user = u; 
                console.log("Firebase Connected:", user ? user.uid : "No User");
            });
        } catch (e) {
            console.warn("Firebase Init Failed (Offline Mode)", e);
        }

        // Expose Network API to Global Scope
        window.NetworkAPI = {
            createRoom: async (difficulty) => {
                if (!user || !db) return null;
                // สร้างเลข 3 หลัก (100 - 999)
                roomId = Math.floor(Math.random() * 900 + 100).toString();
                const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', roomId);
                await setDoc(roomRef, { 
                    host: user.uid, 
                    guest: null, 
                    status: 'waiting', 
                    difficulty: difficulty, // Save difficulty to room
                    lastUpdate: Date.now() 
                });
                isHost = true;
                window.NetworkAPI.listen(roomId);
                return roomId;
            },
            joinRoom: async (id) => {
                if (!user || !db) return false;
                roomId = id;
                const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', roomId);
                const snap = await getDoc(roomRef);
                if (snap.exists() && snap.data().status === 'waiting') {
                    await updateDoc(roomRef, { guest: user.uid, status: 'ready' });
                    isHost = false;
                    window.NetworkAPI.listen(roomId);
                    return true;
                }
                return false;
            },
            listen: (id) => {
                if(!db) return;
                if (unsubscribeRoom) unsubscribeRoom();
                
                unsubscribeRoom = onSnapshot(doc(db, 'artifacts', appId, 'public', 'data', 'rooms', id), (docSnap) => {
                    const data = docSnap.data();
                    if (data) {
                        // Apply room difficulty if joining
                        if (data.difficulty && !isHost) {
                            STATE.difficulty = data.difficulty;
                        }

                        if (data.status === 'ready' && window.onGameStart) window.onGameStart(isHost ? 'blue' : 'red');
                        
                        // Sync Logic
                        if (data.hostData && !isHost && window.updateEnemy) window.updateEnemy(data.hostData);
                        else if (data.guestData && isHost && window.updateEnemy) window.updateEnemy(data.guestData);
                    }
                });
            },
            send: async (data) => {
                if (!roomId || !user || !db) return;
                // Simple throttle
                if (Math.random() > 0.7) {
                    const field = isHost ? 'hostData' : 'guestData';
                    const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', roomId);
                    await updateDoc(roomRef, { [field]: data }).catch(()=>{});
                }
            },
            cancel: async () => {
                if (unsubscribeRoom) {
                    unsubscribeRoom();
                    unsubscribeRoom = null;
                }
                if (isHost && roomId && db) {
                    try {
                        const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', roomId);
                        await deleteDoc(roomRef);
                    } catch(e) { console.log("Error deleting room", e); }
                }
                roomId = null;
                isHost = false;
            }
        };
    </script>
</head>
<body>

    <div id="main-wrapper" class="h-screen w-screen flex flex-col">
        <!-- Game Area -->
        <div id="game-area" class="flex-grow relative bg-green-900">
            <canvas id="game-canvas" class="block w-full h-full"></canvas>
            
            <!-- 1. MAIN MENU -->
            <div id="menu-overlay" class="overlay-screen">
                <h1 class="text-6xl font-black text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-green-400 mb-8 drop-shadow-lg text-center">MATH MOBA</h1>
                <div class="flex flex-col gap-4 w-80">
                    <button onclick="selectMode('single')" class="px-8 py-5 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded-xl text-2xl shadow-lg hover:scale-105 transition-transform border-b-4 border-blue-800">
                        <i class="fas fa-robot mr-2"></i> เล่นคนเดียว
                    </button>
                    <button onclick="selectMode('multiplayer')" class="px-8 py-5 bg-purple-600 hover:bg-purple-500 text-white font-bold rounded-xl text-2xl shadow-lg hover:scale-105 transition-transform border-b-4 border-purple-800">
                        <i class="fas fa-users mr-2"></i> เล่นกับเพื่อน
                    </button>
                </div>
            </div>

            <!-- 2. DIFFICULTY SELECT (Shared) -->
            <div id="difficulty-overlay" class="overlay-screen hidden">
                <h2 class="text-4xl font-bold text-white mb-6">เลือกระดับความยาก</h2>
                <div class="flex flex-col gap-4 w-72">
                    <button onclick="confirmDifficulty('easy')" class="px-6 py-3 bg-green-600 hover:bg-green-500 text-white font-bold rounded-lg text-xl border-b-4 border-green-800">ง่าย (1-9)</button>
                    <button onclick="confirmDifficulty('medium')" class="px-6 py-3 bg-yellow-600 hover:bg-yellow-500 text-white font-bold rounded-lg text-xl border-b-4 border-yellow-800">ปานกลาง (10-99)</button>
                    <button onclick="confirmDifficulty('hard')" class="px-6 py-3 bg-red-600 hover:bg-red-500 text-white font-bold rounded-lg text-xl border-b-4 border-red-800">ยาก (100-999)</button>
                    <button onclick="backToMenu()" class="mt-4 text-gray-400 hover:text-white underline">ย้อนกลับ</button>
                </div>
            </div>

            <!-- 3. LOBBY (Friend Mode) -->
            <div id="lobby-overlay" class="overlay-screen hidden">
                <h2 class="text-4xl font-bold text-purple-300 mb-6">LOBBY</h2>
                <div id="lobby-menu" class="flex flex-col gap-4 w-80">
                    <button onclick="createRoom()" class="px-6 py-4 bg-indigo-600 hover:bg-indigo-500 text-white font-bold rounded-lg text-xl border-b-4 border-indigo-800">สร้างห้องใหม่</button>
                    <div class="flex gap-2">
                        <input type="number" id="join-room-id" placeholder="รหัส 3 หลัก" class="flex-1 px-4 py-2 rounded text-black text-center font-bold border-2 border-indigo-500 text-xl" max="999">
                        <button onclick="joinRoom()" class="px-4 py-2 bg-pink-600 hover:bg-pink-500 text-white font-bold rounded border-b-4 border-pink-800">เข้าร่วม</button>
                    </div>
                    <button onclick="backToDifficulty()" class="mt-4 text-gray-400 hover:text-white underline text-center">ย้อนกลับ</button>
                </div>
                <div id="lobby-waiting" class="hidden flex-col items-center">
                    <div class="text-xl text-gray-300 mb-2">รหัสห้องของคุณ</div>
                    <div id="display-room-id" class="text-8xl font-mono font-black text-yellow-400 bg-black/60 px-10 py-6 rounded-2xl border-4 border-yellow-500/50 mb-8 select-all tracking-widest shadow-[0_0_30px_rgba(250,204,21,0.3)]">...</div>
                    <div class="animate-pulse text-blue-300 mb-8 text-xl"><i class="fas fa-spinner fa-spin mr-2"></i>รอเพื่อนเข้าร่วม...</div>
                    <button onclick="cancelRoom()" class="px-8 py-3 bg-red-600 hover:bg-red-500 text-white font-bold rounded-lg text-xl shadow-lg border-b-4 border-red-800 transition-transform active:scale-95">
                        ยกเลิก
                    </button>
                </div>
            </div>

            <!-- In-Game Elements -->
            <div id="game-ui" class="hidden pointer-events-none absolute inset-0">
                <div id="death-overlay" class="absolute inset-0 bg-gray-900/80 backdrop-blur-md hidden flex-col items-center justify-center z-50">
                    <h2 class="text-6xl font-black text-red-600 mb-4">YOU DIED</h2>
                    <div class="text-white text-4xl font-bold">Respawn: <span id="respawn-timer" class="text-yellow-400">10</span>s</div>
                </div>

                <button onclick="startPlayerRecall()" id="btn-recall" class="absolute bottom-6 right-6 z-30 w-20 h-20 md:w-24 md:h-24 rounded-full bg-blue-600 border-4 border-blue-400 text-white shadow-xl hover:bg-blue-500 pointer-events-auto flex flex-col items-center justify-center">
                    <i class="fas fa-undo-alt text-2xl"></i><span class="text-xs font-bold">Recall</span>
                    <div id="recall-spinner" class="absolute inset-0 rounded-full border-4 border-white border-t-transparent animate-spin hidden"></div>
                </button>

                <div class="absolute top-4 right-4 z-20 pointer-events-auto border-2 border-slate-600 rounded bg-black/80 shadow-lg w-[200px] h-[120px] md:w-[240px] md:h-[140px]">
                    <canvas id="minimap-canvas" class="w-full h-full"></canvas>
                </div>
            </div>
        </div>

        <!-- Control Panel -->
        <div id="ui-panel">
            <div class="flex-1 bg-slate-900 border-r-2 border-slate-700 flex flex-col p-2 min-w-0">
                <div class="flex justify-between items-center mb-2 px-1 text-white">
                    <h3 class="font-bold text-sm"><i class="fas fa-store"></i> ร้านค้า</h3>
                    <span class="text-xs text-yellow-400"><i class="fas fa-coins"></i> <span id="shop-gold-display">0</span></span>
                </div>
                <div id="shop-grid" class="grid grid-cols-2 gap-2 h-full content-start overflow-y-auto pb-2"></div>
            </div>
            
            <div class="flex-1 bg-slate-800 flex flex-col p-2 relative overflow-hidden min-w-0 border-l-2 border-slate-700">
                <div class="flex justify-between items-center mb-2 text-white">
                    <h3 class="font-bold text-sm text-yellow-400"><i class="fas fa-brain"></i> Farm Gold</h3>
                    <span class="text-xs bg-yellow-400/20 px-2 py-1 rounded">+50G</span>
                </div>
                <div class="flex-grow flex flex-col justify-center gap-2 px-1">
                    <div class="bg-black/40 border-2 border-slate-600 rounded-xl p-3 text-center">
                        <span id="math-q" class="text-3xl font-mono font-black text-white tracking-widest">?</span>
                    </div>
                    <div id="math-options-grid" class="grid grid-cols-2 gap-2 h-24"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- MAIN GAME SCRIPT -->
    <script>
        const AudioSys = {
            ctx: null,
            init: function() {
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (AudioContext) {
                        this.ctx = new AudioContext();
                        if(this.ctx.state === 'suspended') this.ctx.resume();
                    }
                } catch(e) { console.log("Audio not supported"); }
            },
            playTone: function(freq, type) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.1);
            }
        };

        const CONFIG = {
            mapW: 3800, mapH: 1400,
            baseHp: 5000, towerHp: 1500,
            spawnRate: 10000, fountainRadius: 350,
            fountainBlueX: 100, fountainRedX: 3700 
        };

        const ASSETS = { colors: { grass: '#064e3b', grassDark: '#022c22', lane: '#78716c', river: '#0ea5e9' } };

        const STATE = {
            active: false, lastTime: 0, gold: 200, 
            cam: { x: 0, y: 0 }, 
            target: null, selectedUnit: null, shake: 0,
            difficulty: 'easy',
            gameMode: 'single'
        };

        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const gameArea = document.getElementById('game-area');
        const mmCanvas = document.getElementById('minimap-canvas');
        const mmCtx = mmCanvas.getContext('2d');

        let entities = [];
        let particles = [];
        let projectiles = [];
        let player = null;
        let enemyHero = null;
        let lastSpawn = 0;
        let currAns = 0;
        let MM_SCALE_X = 1;
        let MM_SCALE_Y = 1;
        
        let pendingMode = 'single';

        // --- UI LOGIC ---
        function selectMode(mode) {
            pendingMode = mode;
            document.getElementById('menu-overlay').classList.add('hidden');
            document.getElementById('difficulty-overlay').classList.remove('hidden');
            document.getElementById('difficulty-overlay').classList.add('flex');
        }

        function confirmDifficulty(diff) {
            STATE.difficulty = diff;
            document.getElementById('difficulty-overlay').classList.add('hidden');
            
            if (pendingMode === 'single') {
                startGame('blue', 'single');
            } else {
                document.getElementById('lobby-overlay').classList.remove('hidden');
                document.getElementById('lobby-overlay').classList.add('flex');
            }
        }

        function backToMenu() {
            document.getElementById('difficulty-overlay').classList.add('hidden');
            document.getElementById('menu-overlay').classList.remove('hidden');
        }

        function backToDifficulty() {
            document.getElementById('lobby-overlay').classList.add('hidden');
            document.getElementById('difficulty-overlay').classList.remove('hidden');
            document.getElementById('difficulty-overlay').classList.add('flex');
        }

        async function createRoom() {
            if(window.NetworkAPI) {
                // Pass difficulty to room creation
                const id = await window.NetworkAPI.createRoom(STATE.difficulty);
                if(id) {
                    document.getElementById('lobby-menu').classList.add('hidden');
                    document.getElementById('lobby-waiting').classList.remove('hidden');
                    document.getElementById('lobby-waiting').classList.add('flex');
                    document.getElementById('display-room-id').innerText = id;
                } else { alert("Network Error"); }
            } else { alert("Firebase not loaded"); }
        }

        async function joinRoom() {
            if(window.NetworkAPI) {
                const id = document.getElementById('join-room-id').value.trim();
                if(!id) return;
                const success = await window.NetworkAPI.joinRoom(id);
                if(success) {
                    document.getElementById('lobby-overlay').classList.add('hidden');
                    // Guest waits for host to start, NetworkAPI listens for ready status
                    // Note: startGame called by network listener for guest
                } else { alert("ไม่พบห้องนี้"); }
            }
        }
        
        function cancelRoom() {
            if(window.NetworkAPI && window.NetworkAPI.cancel) {
                window.NetworkAPI.cancel();
            }
            document.getElementById('lobby-waiting').classList.add('hidden');
            document.getElementById('lobby-waiting').classList.remove('flex');
            document.getElementById('lobby-menu').classList.remove('hidden');
        }

        window.onGameStart = (team) => {
            document.getElementById('lobby-overlay').classList.add('hidden');
            startGame(team, 'multiplayer');
        };
        
        window.updateEnemy = (data) => {
            if (enemyHero) {
                enemyHero.x = data.x; enemyHero.y = data.y;
                enemyHero.hp = data.hp; enemyHero.maxHp = data.maxHp;
            }
        };

        // --- GAME INIT ---
        function startGame(playerTeam, mode) {
            STATE.gameMode = mode;
            STATE.active = true;
            AudioSys.init();
            
            document.getElementById('game-ui').classList.remove('hidden');
            
            entities = []; particles = []; projectiles = [];
            
            const blueBase = new Entity('base', 'blue', 250, CONFIG.mapH/2, 70);
            blueBase.maxHp = CONFIG.baseHp; blueBase.hp = CONFIG.baseHp; blueBase.armor = 60; blueBase.dmg = 240; blueBase.range = 400;
            
            const redBase = new Entity('base', 'red', CONFIG.mapW - 250, CONFIG.mapH/2, 70);
            redBase.maxHp = CONFIG.baseHp; redBase.hp = CONFIG.baseHp; redBase.armor = 60; redBase.dmg = 240; redBase.range = 400;

            spawnTowers();

            player = new Hero(playerTeam);
            enemyHero = new Hero(playerTeam === 'blue' ? 'red' : 'blue');

            STATE.cam.x = Math.max(0, Math.min(player.x - canvas.width/2, CONFIG.mapW - canvas.width));
            STATE.cam.y = Math.max(0, Math.min(player.y - canvas.height/2, CONFIG.mapH - canvas.height));

            generateShop();
            newMath();
            
            requestAnimationFrame(loop);
        }

        // --- ENTITY CLASSES ---
        class Entity {
            constructor(type, team, x, y, radius) {
                this.type = type; this.team = team;
                this.x = x; this.y = y; this.radius = radius;
                this.dead = false;
                this.maxHp = 100; this.hp = 100;
                this.dmg = 10; this.armor = 0; this.atkSpeedBase = 60;
                this.range = 100; this.speed = 0; this.atkCd = 0;
                entities.push(this);
            }
            update() {
                if(this.dead) return;
                if(this.atkCd > 0) this.atkCd--;

                if (this.speed > 0) {
                    let sepX = 0, sepY = 0;
                    entities.forEach(other => {
                        if (other !== this && !other.dead && other.speed > 0) {
                            const dx = this.x - other.x;
                            const dy = this.y - other.y;
                            const d = Math.hypot(dx, dy);
                            const minDist = this.radius + other.radius + 5;
                            if (d < minDist && d > 0.1) { 
                                const push = (minDist - d) / d; 
                                sepX += dx * push * 0.1;
                                sepY += dy * push * 0.1;
                            }
                        }
                    });
                    this.x += sepX; this.y += sepY;
                }

                if (this.speed > 0 || this.type === 'tower' || this.type === 'base') {
                    let target = this.findTarget();
                    if (target) {
                        const d = Math.hypot(target.x - this.x, target.y - this.y);
                        if (d <= this.range) {
                            if (this.atkCd <= 0) {
                                this.fire(target);
                                this.atkCd = this.atkSpeedBase;
                            }
                        } else if (this.speed > 0) {
                            if (this !== player && !(STATE.gameMode === 'multiplayer' && this === enemyHero)) {
                                this.moveTowards(target.x, target.y);
                            }
                        }
                    } else if (this.speed > 0 && this !== player) {
                        const destX = this.team === 'blue' ? CONFIG.fountainRedX : CONFIG.fountainBlueX;
                        this.moveTowards(destX, CONFIG.mapH/2);
                    }
                }
            }
            findTarget() {
                let closest = null; let minDist = 700;
                entities.forEach(e => {
                    if (e.team !== this.team && !e.dead) {
                        const d = Math.hypot(e.x - this.x, e.y - this.y);
                        let score = d;
                        if (e.type === 'hero') score -= 200; 
                        if (score < minDist) { minDist = score; closest = e; }
                    }
                });
                return closest;
            }
            moveTowards(tx, ty) {
                const angle = Math.atan2(ty - this.y, tx - this.x);
                this.x += Math.cos(angle) * this.speed;
                this.y += Math.sin(angle) * this.speed;
            }
            fire(target) {
                projectiles.push({ x: this.x, y: this.y, tx: target, speed: 15, color: this.team==='blue'?'#60a5fa':'#f87171' });
                if (this === player) AudioSys.playTone(600, 'square');
            }
            takeDamage(amt) {
                const finalDmg = Math.max(1, amt * (100/(100+this.armor)));
                this.hp -= finalDmg;
                createDamageText(this.x, this.y, finalDmg, this.team==='blue'?'#ef4444':'#ffffff');
                if (this.hp <= 0) {
                    this.hp = 0;
                    if (this.type === 'hero') {
                        this.dead = true;
                        if (this === player) player.startRespawn();
                        else if (this === enemyHero) enemyHero.startRespawn();
                    } else {
                        this.dead = true;
                    }
                    if (this.team !== player.team && this.dead) {
                        STATE.gold += (this.type==='hero'?300:(this.type==='minion'?30:500));
                        updateHud();
                    }
                }
            }
            draw(ctx) {
                if (this.dead) return;
                ctx.fillStyle = this.team==='blue'?'#3b82f6':'#ef4444';
                ctx.beginPath(); 
                if (this.type==='base') ctx.arc(this.x, this.y, 70, 0, Math.PI*2);
                else if (this.type==='tower') ctx.rect(this.x-25, this.y-40, 50, 80);
                else ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
                ctx.fill();
                ctx.fillStyle = '#000'; ctx.fillRect(this.x-30, this.y-this.radius-15, 60, 6);
                ctx.fillStyle = this.team==='blue'?'#60a5fa':'#f87171'; 
                ctx.fillRect(this.x-30, this.y-this.radius-15, 60 * (this.hp/this.maxHp), 6);
            }
        }

        class Hero extends Entity {
            constructor(team) {
                super('hero', team, 0, 0, 25);
                this.maxHp = 600; this.hp = 600; this.dmg = 60; this.armor = 15; this.range = 250; this.speed = 5;
                this.spawn();
                this.respawnTimer = 0;
                this.isRecalling = false;
            }
            spawn() {
                this.x = this.team === 'blue' ? CONFIG.fountainBlueX : CONFIG.fountainRedX;
                this.y = CONFIG.mapH / 2;
                this.hp = this.maxHp;
                this.dead = false;
            }
            startRespawn() {
                this.dead = true;
                this.respawnTimer = 10;
                if (this === player) {
                    document.getElementById('death-overlay').classList.remove('hidden');
                    document.getElementById('death-overlay').classList.add('flex');
                }
            }
            update() {
                if (this.dead) {
                    this.respawnTimer -= 1/60;
                    if (this === player) document.getElementById('respawn-timer').innerText = Math.ceil(this.respawnTimer);
                    if (this.respawnTimer <= 0) {
                        this.spawn();
                        if (this === player) {
                            document.getElementById('death-overlay').classList.add('hidden');
                            document.getElementById('death-overlay').classList.remove('flex');
                        }
                    }
                    return;
                }

                if (this === player) {
                    if (this.isRecalling) {
                        this.recallTimer--;
                        if (this.recallTimer <= 0) {
                            this.spawn();
                            this.isRecalling = false;
                            document.getElementById('recall-spinner').classList.add('hidden');
                        }
                    }
                    if (STATE.target) {
                        const d = Math.hypot(STATE.target.x - this.x, STATE.target.y - this.y);
                        if (d > 5) {
                            this.moveTowards(STATE.target.x, STATE.target.y);
                            if (this.isRecalling) { 
                                this.isRecalling = false; 
                                document.getElementById('recall-spinner').classList.add('hidden');
                            }
                        } else { STATE.target = null; }
                    }
                    if (STATE.gameMode === 'multiplayer' && window.NetworkAPI) window.NetworkAPI.send({x:this.x, y:this.y, hp:this.hp, maxHp:this.maxHp});
                    const homeX = this.team === 'blue' ? CONFIG.fountainBlueX : CONFIG.fountainRedX;
                    if (Math.hypot(this.x - homeX, this.y - CONFIG.mapH/2) < CONFIG.fountainRadius) {
                        this.hp = Math.min(this.hp + 5, this.maxHp);
                    }
                }
                
                super.update();
            }
        }

        function startPlayerRecall() {
            if (player && !player.dead && !player.isRecalling) {
                player.isRecalling = true;
                player.recallTimer = 180;
                document.getElementById('recall-spinner').classList.remove('hidden');
            }
        }

        function spawnTowers() {
            new Entity('tower', 'blue', 1000, CONFIG.mapH/2, 40);
            new Entity('tower', 'blue', 1800, CONFIG.mapH/2, 40);
            new Entity('tower', 'red', CONFIG.mapW-1000, CONFIG.mapH/2, 40);
            new Entity('tower', 'red', CONFIG.mapW-1800, CONFIG.mapH/2, 40);
        }

        function createDamageText(x, y, val, color) {
            const el = document.createElement('div');
            el.className = 'damage-text';
            el.style.color = color;
            el.innerText = Math.round(val);
            const screenX = x - STATE.cam.x;
            const screenY = y - STATE.cam.y;
            if (screenX > 0 && screenX < canvas.width && screenY > 0 && screenY < canvas.height) {
                el.style.left = screenX + 'px';
                el.style.top = screenY + 'px';
                gameArea.appendChild(el);
                setTimeout(() => el.remove(), 600);
            } else { el.remove(); }
        }

        function newMath() {
            const op = Math.random() > 0.5 ? '+' : '-';
            let min = 1, max = 9;
            if (STATE.difficulty === 'medium') { min = 10; max = 99; }
            if (STATE.difficulty === 'hard') { min = 100; max = 999; }
            
            const ans = Math.floor(Math.random() * (max - min)) + min;
            const a = Math.floor(Math.random() * ans);
            const b = op === '+' ? ans - a : a - ans;
            
            let qText = `${Math.abs(a)} + ${Math.abs(ans-a)} = ?`;
            if (op === '-') qText = `${ans + Math.abs(a)} - ${Math.abs(a)} = ?`;
            
            document.getElementById('math-q').innerText = qText;
            
            const grid = document.getElementById('math-options-grid');
            grid.innerHTML = '';
            let opts = [ans];
            for(let i=0; i<100; i++) {
                if (opts.length >= 4) break;
                let fake = ans + Math.floor(Math.random() * 20) - 10;
                if (!opts.includes(fake) && fake >= 0) opts.push(fake);
            }
            opts.sort(() => Math.random()-0.5).forEach(o => {
                const btn = document.createElement('button');
                btn.className = 'bg-slate-700 text-white font-bold rounded shadow active:scale-95';
                btn.innerText = o;
                btn.onclick = () => {
                    if (o === ans) { STATE.gold += 50; updateHud(); newMath(); AudioSys.playTone(800, 'sine'); }
                    else { btn.classList.add('bg-red-500'); setTimeout(newMath, 500); }
                };
                grid.appendChild(btn);
            });
        }

        function generateShop() {
            const grid = document.getElementById('shop-grid');
            const items = [
                { n: "ดาบ", d: "+20 DMG", c: 200, act: () => player.dmg += 20 },
                { n: "เกราะ", d: "+20 DEF", c: 200, act: () => player.armor += 20 },
                { n: "รองเท้า", d: "+SPD", c: 200, act: () => player.atkSpeedBase = Math.max(20, player.atkSpeedBase - 10) },
                { n: "ยา", d: "+HP", c: 100, act: () => player.hp = Math.min(player.hp + 200, player.maxHp) }
            ];
            grid.innerHTML = '';
            items.forEach(i => {
                const btn = document.createElement('button');
                btn.className = 'shop-card bg-slate-800 p-2 rounded border border-slate-600 text-white text-left';
                btn.innerHTML = `<div class="font-bold text-sm">${i.n}</div><div class="text-xs text-gray-400">${i.d}</div><div class="text-yellow-400 font-mono text-xs">${i.c}G</div>`;
                btn.onclick = () => {
                    if (STATE.gold >= i.c) {
                        STATE.gold -= i.c; i.act(); updateHud(); AudioSys.playTone(600, 'triangle');
                    }
                };
                grid.appendChild(btn);
            });
        }

        function updateHud() {
            if (!player) return;
            document.getElementById('shop-gold-display').innerText = STATE.gold;
        }

        function loop() {
            if (!STATE.active) return;
            requestAnimationFrame(loop);

            const now = Date.now();
            if (now - lastSpawn > CONFIG.spawnRate) {
                new Minion('blue', 'mid'); new Minion('red', 'mid');
                lastSpawn = now;
            }

            entities.forEach(e => e.update());
            
            projectiles = projectiles.filter(p => {
                const dx = p.tx.x - p.x;
                const dy = p.tx.y - p.y;
                const dist = Math.hypot(dx, dy);
                if (dist < 10) {
                    p.tx.takeDamage(10);
                    return false; 
                }
                const angle = Math.atan2(dy, dx);
                p.x += Math.cos(angle) * p.speed;
                p.y += Math.sin(angle) * p.speed;
                return true;
            });

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (player) {
                STATE.cam.x = Math.max(0, Math.min(player.x - canvas.width/2, CONFIG.mapW - canvas.width));
                STATE.cam.y = Math.max(0, Math.min(player.y - canvas.height/2, CONFIG.mapH - canvas.height));
            }
            
            ctx.save();
            ctx.translate(-STATE.cam.x, -STATE.cam.y);
            
            ctx.fillStyle = ASSETS.colors.grassDark; ctx.fillRect(0,0, CONFIG.mapW, CONFIG.mapH);
            ctx.fillStyle = '#064e3b'; ctx.beginPath(); ctx.arc(CONFIG.fountainBlueX, CONFIG.mapH/2, CONFIG.fountainRadius, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#450a0a'; ctx.beginPath(); ctx.arc(CONFIG.fountainRedX, CONFIG.mapH/2, CONFIG.fountainRadius, 0, Math.PI*2); ctx.fill();
            
            ctx.strokeStyle = '#64748b'; ctx.lineWidth = 100; ctx.lineCap = 'round';
            ctx.beginPath(); ctx.moveTo(0, CONFIG.mapH/2); ctx.lineTo(CONFIG.mapW, CONFIG.mapH/2); ctx.stroke();

            entities.forEach(e => e.draw(ctx));
            projectiles.forEach(p => {
                ctx.fillStyle = p.color || 'yellow'; ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, Math.PI*2); ctx.fill();
            });

            ctx.restore();

            mmCtx.fillStyle = '#000'; mmCtx.fillRect(0,0, mmCanvas.width, mmCanvas.height);
            entities.forEach(e => {
                const mx = e.x * (mmCanvas.width / CONFIG.mapW);
                const my = e.y * (mmCanvas.height / CONFIG.mapH);
                mmCtx.fillStyle = e.team === 'blue' ? '#3b82f6' : '#ef4444';
                mmCtx.beginPath(); mmCtx.arc(mx, my, e.type==='base'?4:2, 0, Math.PI*2); mmCtx.fill();
            });
        }

        canvas.addEventListener('mousedown', (e) => {
            if(!player) return;
            const rect = canvas.getBoundingClientRect();
            const worldX = e.clientX - rect.left + STATE.cam.x;
            const worldY = e.clientY - rect.top + STATE.cam.y;
            
            let clicked = null;
            entities.forEach(ent => {
                if (ent.team !== player.team && !ent.dead && Math.hypot(ent.x - worldX, ent.y - worldY) < ent.radius + 10) {
                    clicked = ent;
                }
            });

            if (clicked) {
                STATE.selectedUnit = clicked;
            }
            STATE.target = { x: worldX, y: worldY };
        });

        function resize() {
            canvas.width = gameArea.clientWidth;
            canvas.height = gameArea.clientHeight;
            const mmRect = mmCanvas.parentElement.getBoundingClientRect();
            mmCanvas.width = mmRect.width;
            mmCanvas.height = mmRect.height;
        }
        window.addEventListener('resize', resize);
        resize();

    </script>
</body>
</html>
