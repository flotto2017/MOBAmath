<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Math ROV: Mobile Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    
    <style>
        body { overscroll-behavior: none; user-select: none; -webkit-user-select: none; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #020617; }
        #game-area { flex-grow: 1; position: relative; overflow: hidden; background-color: #052e16; cursor: crosshair; touch-action: none; }
        
        #ui-panel { height: 280px; background-color: #0f172a; border-top: 4px solid #1e293b; display: flex; flex-direction: row; box-shadow: 0 -10px 30px rgba(0,0,0,0.8); z-index: 50; }

        .damage-text { position: absolute; color: white; font-weight: 900; font-size: 24px; pointer-events: none; animation: floatPop 0.6s cubic-bezier(0.18, 0.89, 0.32, 1.28) forwards; text-shadow: 2px 2px 0px #000; z-index: 100; -webkit-text-stroke: 1.5px black; }
        @media (min-width: 768px) { .damage-text { font-size: 36px; } }
        @keyframes floatPop { 0% { transform: translateY(0) scale(0.5); opacity: 0; } 20% { transform: translateY(-10px) scale(1.2); opacity: 1; } 100% { transform: translateY(-50px) scale(1); opacity: 0; } }

        .overlay-screen { position: absolute; inset: 0; z-index: 100; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .hidden { display: none !important; }
        
        .shop-card:active { transform: scale(0.98); }
        .shop-card:hover { border-color: #60a5fa; background-color: #1e293b; }
        .btn-press:active { transform: scale(0.95); }

        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #0f172a; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }

        /* JOYSTICK STYLES */
        #joystick-zone {
            position: absolute; bottom: 20px; left: 20px; width: 150px; height: 150px; z-index: 40;
            display: flex; align-items: center; justify-content: center;
            pointer-events: auto; /* Enable touch */
        }
        #joystick-bg {
            width: 120px; height: 120px; background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%; position: relative; backdrop-filter: blur(4px);
        }
        #joystick-stick {
            width: 50px; height: 50px; background: rgba(59, 130, 246, 0.8); border: 2px solid white;
            border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.5);
            transition: transform 0.1s;
        }
    </style>

    <!-- FIREBASE MODULE -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, updateDoc, collection, getDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyDSRWRHZ0tSWBolCjtzcz9SHtozIimqXNQ",
            authDomain: "mobamath-d7343.firebaseapp.com",
            projectId: "mobamath-d7343",
            storageBucket: "mobamath-d7343.firebasestorage.app",
            messagingSenderId: "1073634282918",
            appId: "1:1073634282918:web:576aab55ae51ed02a11367",
            measurementId: "G-WVF93G5ZC8"
        };

        const appId = 'math-moba-v1';
        let db, auth, user, roomId;
        let isHost = false;
        let unsubscribeRoom = null;

        try {
            const app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            signInAnonymously(auth).catch(e => console.warn("Offline:", e));
            onAuthStateChanged(auth, (u) => { user = u; });
        } catch (e) { console.warn("Firebase Init Failed", e); }

        window.NetworkAPI = {
            createRoom: async (difficulty) => {
                if (!user || !db) return null;
                roomId = Math.floor(Math.random() * 900 + 100).toString();
                const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', roomId);
                await setDoc(roomRef, { host: user.uid, guest: null, status: 'waiting', difficulty: difficulty, lastUpdate: Date.now() });
                isHost = true;
                window.NetworkAPI.listen(roomId);
                return roomId;
            },
            joinRoom: async (id) => {
                if (!user || !db) return false;
                roomId = id;
                const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', roomId);
                const snap = await getDoc(roomRef);
                if (snap.exists() && snap.data().status === 'waiting') {
                    await updateDoc(roomRef, { guest: user.uid, status: 'ready' });
                    isHost = false;
                    window.NetworkAPI.listen(roomId);
                    return true;
                }
                return false;
            },
            listen: (id) => {
                if(!db) return;
                if (unsubscribeRoom) unsubscribeRoom();
                unsubscribeRoom = onSnapshot(doc(db, 'artifacts', appId, 'public', 'data', 'rooms', id), (docSnap) => {
                    const data = docSnap.data();
                    if (data) {
                        if (data.difficulty && !isHost) { if (window.setDifficulty) window.setDifficulty(data.difficulty); }
                        if (data.status === 'ready' && window.onGameStart) window.onGameStart(isHost ? 'blue' : 'red');
                        if (data.hostData && !isHost && window.updateEnemy) window.updateEnemy(data.hostData);
                        else if (data.guestData && isHost && window.updateEnemy) window.updateEnemy(data.guestData);
                    }
                });
            },
            send: async (data) => {
                if (!roomId || !user || !db) return;
                if (Math.random() > 0.7) {
                    const field = isHost ? 'hostData' : 'guestData';
                    const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', roomId);
                    await updateDoc(roomRef, { [field]: data }).catch(()=>{});
                }
            },
            cancel: async () => {
                if (unsubscribeRoom) { unsubscribeRoom(); unsubscribeRoom = null; }
                if (isHost && roomId && db) {
                    try { await deleteDoc(doc(db, 'artifacts', appId, 'public', 'data', 'rooms', roomId)); } catch(e) {}
                }
                roomId = null; isHost = false;
            }
        };
    </script>
</head>
<body class="flex flex-col h-screen w-screen bg-gray-900 text-white">

    <div id="main-wrapper" class="flex flex-col h-full w-full">
        <!-- Game Area -->
        <div id="game-area">
            <canvas id="game-canvas" class="block w-full h-full"></canvas>
            
            <!-- JOYSTICK -->
            <div id="joystick-zone">
                <div id="joystick-bg"><div id="joystick-stick"></div></div>
            </div>

            <!-- 1. MAIN MENU -->
            <div id="menu-overlay" class="overlay-screen">
                <h1 class="text-6xl md:text-8xl font-black text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-green-400 mb-8 drop-shadow-lg text-center">MATH MOBA</h1>
                <div class="flex flex-col gap-6 w-96">
                    <button onclick="selectMode('single')" class="px-8 py-6 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded-2xl text-3xl shadow-xl hover:scale-105 transition-transform border-b-8 border-blue-800 flex items-center justify-center gap-4">
                        <i class="fas fa-robot"></i> ‡πÄ‡∏•‡πà‡∏ô‡∏Ñ‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
                    </button>
                    <button onclick="selectMode('multiplayer')" class="px-8 py-6 bg-purple-600 hover:bg-purple-500 text-white font-bold rounded-2xl text-3xl shadow-xl hover:scale-105 transition-transform border-b-8 border-purple-800 flex items-center justify-center gap-4">
                        <i class="fas fa-users"></i> ‡πÄ‡∏•‡πà‡∏ô‡∏Å‡∏±‡∏ö‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô
                    </button>
                </div>
            </div>

            <!-- 2. DIFFICULTY SELECT -->
            <div id="difficulty-overlay" class="overlay-screen hidden">
                <h2 class="text-5xl font-bold text-white mb-8">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏Å</h2>
                <div class="flex flex-col gap-5 w-80">
                    <button onclick="confirmDifficulty('easy')" class="px-6 py-4 bg-green-600 hover:bg-green-500 text-white font-bold rounded-xl text-2xl border-b-4 border-green-800">‡∏á‡πà‡∏≤‡∏¢ (1-9)</button>
                    <button onclick="confirmDifficulty('medium')" class="px-6 py-4 bg-yellow-600 hover:bg-yellow-500 text-white font-bold rounded-xl text-2xl border-b-4 border-yellow-800">‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á (10-99)</button>
                    <button onclick="confirmDifficulty('hard')" class="px-6 py-4 bg-red-600 hover:bg-red-500 text-white font-bold rounded-xl text-2xl border-b-4 border-red-800">‡∏¢‡∏≤‡∏Å (100-999)</button>
                    <button onclick="backToMenu()" class="mt-4 text-xl text-gray-400 hover:text-white underline">‡∏¢‡πâ‡∏≠‡∏ô‡∏Å‡∏•‡∏±‡∏ö</button>
                </div>
            </div>

            <!-- 3. LOBBY -->
            <div id="lobby-overlay" class="overlay-screen hidden">
                <h2 class="text-5xl font-bold text-purple-300 mb-8">LOBBY</h2>
                <div id="lobby-menu" class="flex flex-col gap-6 w-96">
                    <button onclick="createRoom()" class="px-6 py-5 bg-indigo-600 hover:bg-indigo-500 text-white font-bold rounded-xl text-2xl border-b-4 border-indigo-800">‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡πâ‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà</button>
                    <div class="flex gap-2">
                        <input type="number" id="join-room-id" placeholder="‡∏£‡∏´‡∏±‡∏™ 3 ‡∏´‡∏•‡∏±‡∏Å" class="flex-1 px-4 py-3 rounded-xl text-black text-center font-bold border-4 border-indigo-500 text-2xl" max="999">
                        <button onclick="joinRoom()" class="px-6 py-3 bg-pink-600 hover:bg-pink-500 text-white font-bold rounded-xl border-b-4 border-pink-800 text-xl">‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°</button>
                    </div>
                    <button onclick="backToDifficulty()" class="mt-4 text-xl text-gray-400 hover:text-white underline text-center">‡∏¢‡πâ‡∏≠‡∏ô‡∏Å‡∏•‡∏±‡∏ö</button>
                </div>
                <div id="lobby-waiting" class="hidden flex-col items-center">
                    <div class="text-2xl text-gray-300 mb-4">‡∏£‡∏´‡∏±‡∏™‡∏´‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì</div>
                    <div id="display-room-id" class="text-9xl font-mono font-black text-yellow-400 bg-black/60 px-12 py-8 rounded-3xl border-4 border-yellow-500/50 mb-10 select-all tracking-widest shadow-[0_0_30px_rgba(250,204,21,0.3)]">...</div>
                    <div class="animate-pulse text-blue-300 mb-8 text-2xl"><i class="fas fa-spinner fa-spin mr-2"></i>‡∏£‡∏≠‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°...</div>
                    <button onclick="cancelRoom()" class="px-10 py-4 bg-red-600 hover:bg-red-500 text-white font-bold rounded-lg text-xl shadow-lg border-b-4 border-red-800 transition-transform active:scale-95">
                        ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å
                    </button>
                </div>
            </div>

            <!-- In-Game Elements (Death, Recall, HUD) -->
            <div id="game-ui" class="hidden pointer-events-none absolute inset-0">
                <div id="death-overlay" class="absolute inset-0 bg-gray-900/80 backdrop-blur-md hidden flex-col items-center justify-center z-50">
                    <h2 class="text-7xl md:text-9xl font-black text-red-600 mb-4 drop-shadow-lg">YOU DIED</h2>
                    <div class="text-white text-5xl font-bold">Respawn: <span id="respawn-timer" class="text-yellow-400 font-mono text-7xl">10</span>s</div>
                </div>

                <button onclick="startPlayerRecall()" id="btn-recall" class="absolute bottom-6 right-6 z-30 w-24 h-24 md:w-28 md:h-28 rounded-full bg-blue-600 border-4 border-blue-400 text-white shadow-xl hover:bg-blue-500 pointer-events-auto flex flex-col items-center justify-center group transition-all active:scale-95">
                    <i class="fas fa-undo-alt text-3xl mb-1 group-hover:-rotate-45 transition-transform"></i>
                    <span class="text-sm font-bold uppercase">Recall</span>
                    <div id="recall-spinner" class="absolute inset-0 rounded-full border-4 border-white border-t-transparent animate-spin hidden"></div>
                </button>

                <!-- Player Status (Big Text) -->
                <div class="absolute top-4 left-4 z-20 flex gap-3 pointer-events-none select-none">
                    <div class="relative w-24 h-24 md:w-28 md:h-28 rounded-xl border-4 border-slate-700 shadow-2xl overflow-hidden bg-slate-800">
                        <div class="absolute inset-0 flex items-center justify-center text-5xl text-blue-400"><i class="fas fa-user-ninja"></i></div>
                        <div class="absolute bottom-0 w-full text-center bg-black/70 text-sm md:text-base text-white font-bold py-1">LV.<span id="hud-level">1</span></div>
                    </div>
                    <div class="flex flex-col justify-center gap-2 min-w-[200px] md:min-w-[240px]">
                        <div class="h-8 bg-gray-900 rounded border border-gray-600 relative overflow-hidden">
                            <div id="hud-hp-bar" class="h-full bg-gradient-to-r from-green-600 to-green-400 w-full transition-all duration-300"></div>
                            <span class="absolute inset-0 text-sm md:text-base text-white flex items-center justify-center font-bold drop-shadow-md tracking-wider">
                                <i class="fas fa-heart text-red-500 mr-2"></i> <span id="hud-hp-text">500/500</span>
                            </span>
                        </div>
                        <div class="grid grid-cols-2 gap-x-3 gap-y-2 bg-black/60 p-2 rounded border border-slate-600/50 backdrop-blur-sm">
                            <div class="flex items-center text-sm md:text-base text-white font-bold"><i class="fas fa-khanda text-red-400 w-6"></i> <span id="hud-atk">45</span></div>
                            <div class="flex items-center text-sm md:text-base text-white font-bold"><i class="fas fa-shield-alt text-blue-400 w-6"></i> <span id="hud-armor">0</span></div>
                            <div class="flex items-center text-sm md:text-base text-white font-bold"><i class="fas fa-bolt text-yellow-400 w-6"></i> <span id="hud-aspd">1.0</span></div>
                            <div class="flex items-center text-sm md:text-base text-white font-bold"><i class="fas fa-coins text-yellow-500 w-6"></i> <span id="hud-gold">0</span></div>
                        </div>
                    </div>
                </div>

                <!-- Target Status -->
                <div id="target-panel" class="absolute top-4 left-1/2 transform -translate-x-1/2 z-20 flex gap-3 pointer-events-none select-none transition-opacity duration-200 opacity-0 bg-black/70 backdrop-blur-md p-3 rounded-xl border border-red-500/30 min-w-[200px] md:min-w-[280px]">
                    <div class="relative w-16 h-16 rounded-lg border-2 border-red-500 overflow-hidden bg-slate-800 shrink-0">
                        <div class="absolute inset-0 flex items-center justify-center text-4xl text-red-400"><i id="target-icon" class="fas fa-skull"></i></div>
                    </div>
                    <div class="flex flex-col justify-center w-full">
                        <div class="text-sm md:text-base text-red-200 font-bold uppercase tracking-wider mb-1" id="target-name">Enemy</div>
                        <div class="h-5 bg-gray-900 rounded-full border border-gray-600 relative overflow-hidden mb-1">
                            <div id="target-hp-bar" class="h-full bg-red-600 w-full transition-all duration-200"></div>
                            <div class="absolute inset-0 flex items-center justify-center"><span id="target-hp-text" class="text-xs font-bold text-white drop-shadow-md"></span></div>
                        </div>
                        <div class="flex gap-4 text-xs md:text-sm text-white font-bold">
                            <span>ATK: <span id="target-atk" class="text-red-300">10</span></span>
                            <span>DEF: <span id="target-armor" class="text-blue-300">0</span></span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Game Over -->
            <div id="game-over-overlay" class="absolute inset-0 bg-black/95 z-50 hidden flex-col items-center justify-center text-center pointer-events-auto">
                <div id="end-icon" class="text-9xl mb-8 animate-bounce">üèÜ</div>
                <h1 id="game-result-title" class="text-8xl md:text-9xl font-black mb-6 text-transparent bg-clip-text bg-gradient-to-b from-yellow-300 to-yellow-600">VICTORY</h1>
                <p id="game-result-desc" class="text-gray-400 text-3xl mb-12">The enemy core has been destroyed!</p>
                <button onclick="location.reload()" class="px-16 py-6 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded-2xl text-4xl shadow-lg hover:shadow-blue-500/50 transition-all transform hover:scale-105 btn-press">
                    PLAY AGAIN
                </button>
            </div>
        </div>

        <!-- Control Panel (Layout: Shop - Map - Math) -->
        <div id="ui-panel">
            <!-- SHOP (Left) -->
            <div class="flex-1 bg-slate-900 border-r-2 border-slate-700 flex flex-col p-2 min-w-0">
                <div class="flex justify-between items-center mb-2 px-2 text-white">
                    <h3 class="font-bold text-base md:text-lg flex items-center gap-2"><i class="fas fa-store text-indigo-400"></i> ‡∏£‡πâ‡∏≤‡∏ô‡∏Ñ‡πâ‡∏≤</h3>
                    <span class="text-sm md:text-base text-yellow-400 font-mono"><i class="fas fa-coins"></i> <span id="shop-gold-display">0</span></span>
                </div>
                <div id="shop-grid" class="grid grid-cols-2 gap-2 h-full content-start overflow-y-auto pb-2 px-1"></div>
            </div>

            <!-- MINIMAP (Center) -->
            <div class="w-[280px] md:w-[360px] bg-slate-950 border-r-2 border-slate-700 flex flex-col items-center justify-center relative p-1 shrink-0">
                <canvas id="minimap-canvas" class="border border-slate-600 rounded bg-black/50 cursor-crosshair shadow-inner w-full h-full object-contain"></canvas>
                <div class="absolute bottom-2 right-2 text-xs text-white/50 pointer-events-none font-bold bg-black/40 px-2 rounded backdrop-blur-sm">MAP VIEW</div>
            </div>
            
            <!-- MATH (Right) -->
            <div class="flex-1 bg-slate-800 flex flex-col p-3 relative overflow-hidden min-w-0 border-l-2 border-slate-700">
                <div class="absolute inset-0 bg-[url('https://www.transparenttextures.com/patterns/cubes.png')] opacity-5 pointer-events-none"></div>
                <div class="flex justify-between items-center mb-3 text-white z-10">
                    <h3 class="font-bold text-base md:text-lg text-yellow-400 flex items-center gap-2"><i class="fas fa-brain"></i> Farm Gold</h3>
                    <span class="text-sm font-bold bg-yellow-400/20 px-3 py-1 rounded text-yellow-300 border border-yellow-400/30">+50G</span>
                </div>
                <div class="flex-grow flex flex-col justify-center gap-3 z-10">
                    <div class="bg-black/50 border-2 border-slate-600 rounded-xl p-4 text-center shadow-inner">
                        <span id="math-q" class="text-4xl md:text-5xl font-mono font-black text-white tracking-widest drop-shadow-md">?</span>
                    </div>
                    <div id="math-options-grid" class="grid grid-cols-2 gap-3 h-28"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- MAIN GAME SCRIPT -->
    <script>
        const AudioSys = {
            ctx: null,
            init: function() { try { const AC = window.AudioContext||window.webkitAudioContext; if(AC){this.ctx=new AC(); if(this.ctx.state==='suspended')this.ctx.resume();} }catch(e){} },
            playTone: function(f,t,d=0.1,v=0.1) { if(!this.ctx)return; const o=this.ctx.createOscillator(),g=this.ctx.createGain(); o.type=t||'sine'; o.frequency.value=f; g.gain.value=v; g.gain.exponentialRampToValueAtTime(0.01,this.ctx.currentTime+d); o.connect(g); g.connect(this.ctx.destination); o.start(); o.stop(this.ctx.currentTime+d); },
            shoot: function() { this.playTone(600,'square',0.1,0.05); },
            hit: function() { this.playTone(100,'sawtooth',0.1,0.05); },
            coin: function() { this.playTone(1200,'sine',0.1); setTimeout(()=>this.playTone(1800,'sine',0.2),100); },
            buy: function() { this.playTone(400,'sine'); setTimeout(()=>this.playTone(600,'sine'),100); },
            win: function() { if(!this.ctx)return; [300,400,500,600,800].forEach((f,i)=>setTimeout(()=>this.playTone(f,'square',0.5),i*200)); }
        };

        const CONFIG = { mapW: 3800, mapH: 1400, baseHp: 5000, towerHp: 1500, spawnRate: 10000, fountainRadius: 350, fountainBlueX: 100, fountainRedX: 3700 };
        const ASSETS = { colors: { grass: '#064e3b', grassDark: '#022c22', lane: '#78716c', river: '#0ea5e9' } };
        const STATE = { active: false, lastTime: 0, gold: 200, cam: { x: 0, y: 0 }, target: null, selectedUnit: null, shake: 0, difficulty: 'easy', gameMode: 'single', scale: 1 };
        
        // Joystick State
        const JOY = { active: false, dx: 0, dy: 0, id: null };

        const canvas = document.getElementById('game-canvas'), ctx = canvas.getContext('2d');
        const gameArea = document.getElementById('game-area');
        const mmCanvas = document.getElementById('minimap-canvas'), mmCtx = mmCanvas.getContext('2d');

        let entities = [], particles = [], projectiles = [], player = null, enemyHero = null, lastSpawn = 0, currAns = 0, MM_SCALE_X = 1, MM_SCALE_Y = 1, pendingMode = 'single';
        let blueBase = null, redBase = null;

        // UI HELPERS MUST BE DEFINED BEFORE USE
        function updateHud() {
            if (!player) return;
            const goldEl = document.getElementById('shop-gold-display');
            if(goldEl) goldEl.innerText = STATE.gold;
            const atkEl = document.getElementById('hud-atk');
            if(atkEl) atkEl.innerText = Math.round(player.dmg);
            const defEl = document.getElementById('hud-armor');
            if(defEl) defEl.innerText = Math.round(player.armor);
            const spdEl = document.getElementById('hud-aspd');
            if(spdEl) spdEl.innerText = player.aps;
            const hpTxtEl = document.getElementById('hud-hp-text');
            const dispHp = isNaN(player.hp) ? 0 : Math.floor(player.hp);
            const dispMaxHp = isNaN(player.maxHp) ? 600 : player.maxHp;
            if(hpTxtEl) hpTxtEl.innerText = `${dispHp}/${dispMaxHp}`;
            const hpBarEl = document.getElementById('hud-hp-bar');
            if(hpBarEl) hpBarEl.style.width = (dispHp / dispMaxHp * 100) + '%';
            
            const targetPanel = document.getElementById('target-panel');
            if (targetPanel) {
                if (STATE.selectedUnit && !STATE.selectedUnit.dead) {
                    targetPanel.classList.remove('opacity-0');
                    const t = STATE.selectedUnit;
                    const tHp = isNaN(t.hp) ? 0 : Math.floor(t.hp);
                    const tMaxHp = isNaN(t.maxHp) ? 100 : t.maxHp;
                    document.getElementById('target-name').innerText = t.type.toUpperCase();
                    document.getElementById('target-hp-text').innerText = `${tHp}/${tMaxHp}`;
                    document.getElementById('target-hp-bar').style.width = (tHp / tMaxHp * 100) + '%';
                    document.getElementById('target-atk').innerText = Math.round(t.dmg || 0);
                    document.getElementById('target-armor').innerText = Math.round(t.armor || 0);
                    const icon = document.getElementById('target-icon');
                    if (t.type === 'base') icon.className = 'fas fa-gem';
                    else if (t.type === 'tower') icon.className = 'fas fa-chess-rook';
                    else icon.className = 'fas fa-skull';
                } else { targetPanel.classList.add('opacity-0'); }
            }
        }

        function createDamageText(x, y, val, color) {
            if(Math.random()>0.8)return;
            const el=document.createElement('div'); el.className='damage-text'; el.style.color=color; el.innerText=Math.round(val);
            // Adjusted screen position calculation for scaling
            const sx = (x - STATE.cam.x) * STATE.scale;
            const sy = (y - STATE.cam.y) * STATE.scale;
            
            if(sx>0&&sx<canvas.width&&sy>0&&sy<canvas.height) { el.style.left=sx+'px'; el.style.top=sy+'px'; gameArea.appendChild(el); setTimeout(()=>el.remove(),600); }
        }

        function createFloatingText(x, y, text, color) {
            const el=document.createElement('div'); el.className='damage-text'; el.style.color=color; el.innerText=text; el.style.fontSize='30px'; el.style.zIndex='101';
             const sx = (x - STATE.cam.x) * STATE.scale;
             const sy = (y - STATE.cam.y) * STATE.scale;
            el.style.left=sx+'px'; el.style.top=(sy-30)+'px'; gameArea.appendChild(el); setTimeout(()=>el.remove(),800);
        }

        function gameOver(win) {
            STATE.active = false;
            AudioSys.win();
            document.getElementById('game-over-overlay').classList.remove('hidden');
            document.getElementById('game-over-overlay').classList.add('flex');
            const title = document.getElementById('game-result-title');
            if (win) title.innerText = "VICTORY";
            else { title.innerText = "DEFEAT"; title.className = "text-7xl font-black mb-2 text-gray-500"; }
        }

        // --- CLASSES ---
        class Entity {
            constructor(type, team, x, y, radius) {
                this.type=type; this.team=team; this.x=x; this.y=y; this.radius=radius;
                this.dead=false; this.maxHp=100; this.hp=100; this.dmg=10; this.armor=0; this.atkSpeedBase=60;
                this.range=100; this.speed=0; this.atkCd=0;
                entities.push(this);
            }
            get aps() { return (60/Math.max(5,this.atkSpeedBase)).toFixed(1); }
            update() {
                if(this.dead)return;
                if(this.atkCd>0)this.atkCd--;
                if(this.speed>0) {
                    let sx=0, sy=0;
                    entities.forEach(o=>{
                        if(o!==this && !o.dead && o.speed>0) {
                            const dx=this.x-o.x, dy=this.y-o.y, d=Math.hypot(dx,dy), md=this.radius+o.radius+5;
                            if(d<md && d>0.1) { const p=(md-d)/d; sx+=dx*p*0.1; sy+=dy*p*0.1; }
                        }
                    });
                    this.x+=sx; this.y+=sy;
                }
                if(this.speed>0||this.type==='tower'||this.type==='base') {
                    let t=this.findTarget();
                    if(t) {
                        const d=Math.hypot(t.x-this.x, t.y-this.y);
                        if(d<=this.range) { if(this.atkCd<=0){ this.fire(t); this.atkCd=this.atkSpeedBase; } }
                        else if(this.speed>0) {
                            if(this!==player && !(STATE.gameMode==='multiplayer'&&this===enemyHero)) this.moveTowards(t.x, t.y);
                        }
                    } else if(this.speed>0 && this!==player && !(STATE.gameMode==='multiplayer'&&this===enemyHero)) {
                        this.moveTowards(this.team==='blue'?CONFIG.fountainRedX:CONFIG.fountainBlueX, CONFIG.mapH/2);
                    }
                }
            }
            findTarget() {
                let c=null, md=700;
                entities.forEach(e=>{
                    if(e.team!==this.team && !e.dead) {
                        const d=Math.hypot(e.x-this.x, e.y-this.y);
                        let s=d; if(e.type==='hero')s-=200;
                        if(s<md) { md=s; c=e; }
                    }
                });
                return c;
            }
            moveTowards(tx, ty) {
                const a=Math.atan2(ty-this.y, tx-this.x);
                this.x+=Math.cos(a)*this.speed; this.y+=Math.sin(a)*this.speed;
            }
            fire(t) {
                projectiles.push({x:this.x, y:this.y, tx:t, speed:15, color:this.team==='blue'?'#60a5fa':'#f87171'});
                if(this===player) AudioSys.shoot();
            }
            takeDamage(amt) {
                if (isNaN(amt)) amt = 0;
                if(this===player&&player.isRecalling) { player.cancelRecall(); createFloatingText(player.x,player.y,"Interrupted!","#ef4444"); }
                const dmg = Math.max(1, amt * (100 / (100 + (this.armor||0))));
                this.hp -= dmg;
                if(isNaN(this.hp)) this.hp = 0;
                createDamageText(this.x, this.y, dmg, this.team==='blue'?'#ef4444':'#ffffff');
                if(this.hp<=0) {
                    this.hp=0;
                    if(this.type==='hero') { this.dead=true; if(this===player)player.startRespawn(); else if(this===enemyHero)enemyHero.startRespawn(); }
                    else this.dead=true;
                    if(this.dead && this.team!==player.team) {
                        let r=30; if(this.type==='hero')r=300; if(this.type==='tower')r=500; if(this.type==='base')r=2000;
                        if(r>0) { STATE.gold+=r; updateHud(); createFloatingText(this.x,this.y,`+${r}G`,'#facc15'); AudioSys.coin(); }
                    }
                    if(STATE.selectedUnit===this) STATE.selectedUnit=null;
                }
            }
            draw(ctx) {
                if(this.dead)return;
                ctx.fillStyle='rgba(0,0,0,0.4)'; ctx.beginPath(); ctx.ellipse(this.x,this.y+this.radius*0.8,this.radius,this.radius*0.4,0,0,Math.PI*2); ctx.fill();
                
                if((this.type==='tower'||this.type==='base')&&this.team!==player.team) {
                   const d=Math.hypot(player.x-this.x, player.y-this.y);
                   if(d<this.range+200) {
                       ctx.beginPath(); ctx.arc(this.x,this.y,this.range,0,Math.PI*2);
                       ctx.strokeStyle='rgba(239,68,68,0.4)'; ctx.lineWidth=2; ctx.setLineDash([10,10]); ctx.stroke(); ctx.setLineDash([]);
                   } 
                }

                ctx.fillStyle = this.team==='blue'?'#3b82f6':'#ef4444';
                if(this.type==='tower') ctx.fillRect(this.x-25,this.y-40,50,80);
                else if(this.type==='base') { ctx.beginPath(); ctx.arc(this.x,this.y,70,0,Math.PI*2); ctx.fill(); }
                else { ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.fill(); }
                
                if(STATE.selectedUnit===this) { ctx.strokeStyle='#facc15'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(this.x,this.y,this.radius+10,0,Math.PI*2); ctx.stroke(); }
                
                const safeHp = isNaN(this.hp) ? 0 : this.hp;
                const safeMaxHp = isNaN(this.maxHp) || this.maxHp === 0 ? 100 : this.maxHp;
                
                ctx.fillStyle='#000'; ctx.fillRect(this.x-30,this.y-this.radius-15,60,6);
                ctx.fillStyle=this.team==='blue'?'#60a5fa':'#f87171'; ctx.fillRect(this.x-30,this.y-this.radius-15,60*(safeHp/safeMaxHp),6);
            }
        }

        class Hero extends Entity {
            constructor(team) {
                super('hero', team, 0, 0, 25);
                this.maxHp=600; this.hp=600; this.dmg=60; this.armor=15; this.range=220; this.speed=6; // Hero faster
                this.isRecalling=false; this.recallTimer=0; this.maxRecallTime=180; this.respawnTimer=0;
                this.spawn();
            }
            spawn() {
                this.x = this.team==='blue'?CONFIG.fountainBlueX:CONFIG.fountainRedX;
                this.y = CONFIG.mapH/2; this.hp=this.maxHp; this.dead=false;
            }
            startRespawn() {
                this.dead=true; this.respawnTimer=10; this.x=-9999;
                if(this===player) { document.getElementById('death-overlay').classList.remove('hidden'); document.getElementById('death-overlay').classList.add('flex'); }
            }
            update() {
                if(this.dead) {
                    this.respawnTimer -= 1/60;
                    if(this===player) document.getElementById('respawn-timer').innerText=Math.ceil(this.respawnTimer);
                    if(this.respawnTimer<=0) {
                        this.spawn();
                        if(this===player) { document.getElementById('death-overlay').classList.add('hidden'); document.getElementById('death-overlay').classList.remove('flex'); }
                    }
                    return;
                }
                if(this===player) {
                    if(this.isRecalling) {
                        this.recallTimer--;
                        if(this.recallTimer<=0) { this.spawn(); this.isRecalling=false; document.getElementById('recall-spinner').classList.add('hidden'); createFloatingText(this.x,this.y,"Recalled!","#3b82f6"); STATE.target=null; }
                    }
                    
                    // Joystick Movement
                    if (JOY.active) {
                        const moveX = JOY.dx * this.speed;
                        const moveY = JOY.dy * this.speed;
                        this.x += moveX;
                        this.y += moveY;
                        
                        // Cancel Recall/Auto-move
                        if (this.isRecalling) { this.isRecalling = false; document.getElementById('recall-spinner').classList.add('hidden'); }
                        STATE.target = null;
                        
                        // Boundaries
                        this.x = Math.max(0, Math.min(this.x, CONFIG.mapW));
                        this.y = Math.max(0, Math.min(this.y, CONFIG.mapH));
                    }
                    // Tap Movement
                    else if(STATE.target) {
                        const d=Math.hypot(STATE.target.x-this.x, STATE.target.y-this.y);
                        if(d>5) { this.moveTowards(STATE.target.x, STATE.target.y); if(this.isRecalling){ this.isRecalling=false; document.getElementById('recall-spinner').classList.add('hidden'); } }
                        else STATE.target=null;
                    }
                    
                    if(STATE.gameMode==='multiplayer'&&window.NetworkAPI) window.NetworkAPI.send({x:this.x, y:this.y, hp:this.hp, maxHp:this.maxHp});
                    const homeX=this.team==='blue'?CONFIG.fountainBlueX:CONFIG.fountainRedX;
                    if(Math.hypot(this.x-homeX,this.y-CONFIG.mapH/2)<CONFIG.fountainRadius && this.hp<this.maxHp) this.hp=Math.min(this.hp+5, this.maxHp);
                    
                    if(STATE.shake>0) STATE.shake*=0.9;
                    if(STATE.shake<0.5) STATE.shake=0;
                    
                    // Center camera logic in update, but actual clamp happens in Draw/Resize calculations mainly,
                    // but we store it in STATE.cam
                    // IMPORTANT: Limit camera so it doesn't show black bars if possible
                    // But our canvas is full screen, so we just center on player.
                    
                    // Determine max scroll
                    // We need to know current visible width/height in world units
                    // Visible Width = canvas.width / STATE.scale
                    const visW = canvas.width / STATE.scale;
                    const visH = canvas.height / STATE.scale;
                    
                    STATE.cam.x = Math.max(0, Math.min(this.x - visW/2, CONFIG.mapW - visW)) + (Math.random()-0.5)*STATE.shake;
                    STATE.cam.y = Math.max(0, Math.min(this.y - visH/2, CONFIG.mapH - visH)) + (Math.random()-0.5)*STATE.shake;
                }
                super.update();
            }
        }

        class Minion extends Entity {
            constructor(team, lane) {
                const sx = team==='blue'?150:CONFIG.mapW-150;
                const sy = CONFIG.mapH/2;
                super('minion', team, sx, sy, 12);
                this.lane=lane; this.maxHp=250; this.hp=250; this.dmg=15; this.armor=2; this.range=100; this.speed=2.5; this.wpIdx=0;
                this.waypoints = this.getWp(lane, team);
            }
            getWp(lane, team) {
                const w=CONFIG.mapW, h=CONFIG.mapH, m=200;
                if(team==='blue') {
                    if(lane==='mid') return [{x:w-150, y:h/2}];
                    if(lane==='top') return [{x:250,y:m}, {x:w-250,y:m}, {x:w-150,y:h/2}];
                    if(lane==='bot') return [{x:250,y:h-m}, {x:w-250,y:h-m}, {x:w-150,y:h/2}];
                } else {
                    if(lane==='mid') return [{x:150, y:h/2}];
                    if(lane==='top') return [{x:w-250,y:m}, {x:250,y:m}, {x:150,y:h/2}];
                    if(lane==='bot') return [{x:w-250,y:h-m}, {x:250,y:h-m}, {x:150,y:h/2}];
                }
                return [];
            }
            update() {
                if(this.dead)return;
                let t=this.findTarget();
                if(t && Math.hypot(t.x-this.x, t.y-this.y)<=this.range) {
                    if(this.atkCd<=0){ this.fire(t); this.atkCd=this.atkSpeedBase; }
                } else {
                    if(this.wpIdx < this.waypoints.length) {
                        const wp=this.waypoints[this.wpIdx];
                        if(Math.hypot(wp.x-this.x, wp.y-this.y)<20) this.wpIdx++; else this.moveTowards(wp.x, wp.y);
                    } else {
                        this.moveTowards(this.team==='blue'?CONFIG.mapW-150:150, CONFIG.mapH/2);
                    }
                }
                super.update();
            }
        }

        // --- MENU LOGIC ---
        function selectMode(m) { pendingMode = m; document.getElementById('menu-overlay').classList.add('hidden'); document.getElementById('difficulty-overlay').classList.remove('hidden'); document.getElementById('difficulty-overlay').classList.add('flex'); }
        function confirmDifficulty(d) { STATE.difficulty = d; document.getElementById('difficulty-overlay').classList.add('hidden'); if(pendingMode==='single') startGame('blue','single'); else { document.getElementById('lobby-overlay').classList.remove('hidden'); document.getElementById('lobby-overlay').classList.add('flex'); } }
        function backToMenu() { document.getElementById('difficulty-overlay').classList.add('hidden'); document.getElementById('menu-overlay').classList.remove('hidden'); }
        function backToDifficulty() { document.getElementById('lobby-overlay').classList.add('hidden'); document.getElementById('difficulty-overlay').classList.remove('hidden'); document.getElementById('difficulty-overlay').classList.add('flex'); }
        
        async function createRoom() { if(window.NetworkAPI) { const id=await window.NetworkAPI.createRoom(STATE.difficulty); if(id){ document.getElementById('lobby-menu').classList.add('hidden'); document.getElementById('lobby-waiting').classList.remove('hidden'); document.getElementById('lobby-waiting').classList.add('flex'); document.getElementById('display-room-id').innerText=id; } else alert("Error"); } else alert("No Net"); }
        async function joinRoom() { if(window.NetworkAPI) { const id=document.getElementById('join-room-id').value.trim(); if(!id)return; const s=await window.NetworkAPI.joinRoom(id); if(s) document.getElementById('lobby-overlay').classList.add('hidden'); else alert("Not Found"); } }
        function cancelRoom() { if(window.NetworkAPI&&window.NetworkAPI.cancel) window.NetworkAPI.cancel(); document.getElementById('lobby-waiting').classList.add('hidden'); document.getElementById('lobby-waiting').classList.remove('flex'); document.getElementById('lobby-menu').classList.remove('hidden'); }
        
        window.onGameStart = (t) => { if(STATE.active)return; document.getElementById('lobby-overlay').classList.add('hidden'); startGame(t,'multiplayer'); };
        window.setDifficulty = (d) => { STATE.difficulty = d; };
        window.updateEnemy = (d) => { if(enemyHero){ enemyHero.x=d.x; enemyHero.y=d.y; enemyHero.hp=d.hp; enemyHero.maxHp=d.maxHp; } };

        // --- GAME LOGIC ---
        function startGame(team, mode) {
            STATE.gameMode = mode; STATE.active = true; AudioSys.init();
            document.getElementById('game-ui').classList.remove('hidden');
            entities = []; particles = []; projectiles = [];
            
            blueBase = new Entity('base','blue',250,CONFIG.mapH/2,70); blueBase.maxHp=CONFIG.baseHp; blueBase.hp=blueBase.maxHp; blueBase.armor=60; blueBase.dmg=240; blueBase.range=400;
            redBase = new Entity('base','red',CONFIG.mapW-250,CONFIG.mapH/2,70); redBase.maxHp=CONFIG.baseHp; redBase.hp=redBase.maxHp; redBase.armor=60; redBase.dmg=240; redBase.range=400;
            
            spawnTowers();
            player = new Hero(team);
            enemyHero = new Hero(team==='blue'?'red':'blue');

            // Initial resize to set scale before loop
            resize();
            
            generateShop(); newMath(); loop(performance.now());
        }

        function spawnTowers() {
            const w=CONFIG.mapW, h=CONFIG.mapH, m=200;
            new Entity('tower','blue',1000,h/2,40); new Entity('tower','blue',1800,h/2,40);
            new Entity('tower','red',w-1000,h/2,40); new Entity('tower','red',w-1800,h/2,40);
            new Entity('tower','blue',1000,m,40); new Entity('tower','blue',1800,m,40);
            new Entity('tower','red',w-1000,m,40); new Entity('tower','red',w-1800,m,40);
            new Entity('tower','blue',1000,h-m,40); new Entity('tower','blue',1800,h-m,40);
            new Entity('tower','red',w-1000,h-m,40); new Entity('tower','red',w-1800,h-m,40);
        }

        function newMath() {
            const op=Math.random()>0.5?'+':'-';
            let min=1, max=9;
            if(STATE.difficulty==='medium'){min=10;max=99;} if(STATE.difficulty==='hard'){min=100;max=999;}
            currAns = Math.floor(Math.random()*(max-min+1))+min;
            let a = Math.floor(Math.random()*currAns);
            let b = op==='+' ? currAns-a : a-currAns;
            if(op==='+') { a=Math.floor(Math.random()*currAns); b=currAns-a; }
            else { b=Math.floor(Math.random()*currAns); a=currAns+b; }
            
            document.getElementById('math-q').innerText = `${a} ${op} ${b} = ?`;
            const grid=document.getElementById('math-options-grid'); grid.innerHTML='';
            let opts=[currAns];
            for(let i=0;i<20;i++) { if(opts.length>=4)break; let f=currAns+Math.floor(Math.random()*20)-10; if(!opts.includes(f)&&f>=0)opts.push(f); }
            opts.sort(()=>Math.random()-0.5).forEach(o=>{
                const btn=document.createElement('button');
                btn.className='bg-slate-700 hover:bg-slate-600 text-white font-bold rounded-lg text-lg md:text-2xl border-b-4 border-slate-900 active:translate-y-0.5 transition-all shadow';
                btn.innerText=o;
                btn.onclick=()=> { if(o===currAns){ STATE.gold+=50; updateHud(); newMath(); AudioSys.coin(); } else { btn.classList.add('bg-red-600'); setTimeout(newMath,500); } };
                grid.appendChild(btn);
            });
        }

        function generateShop() {
            const grid=document.getElementById('shop-grid');
            const items=[
                {n:"‡∏î‡∏≤‡∏ö",d:"+20 ATK",c:200,i:"fa-khanda",cl:"text-red-400",act:()=>{player.dmg+=20;}},
                {n:"‡πÄ‡∏Å‡∏£‡∏≤‡∏∞",d:"+20 DEF",c:200,i:"fa-shield-alt",cl:"text-blue-400",act:()=>{player.armor+=20;}},
                {n:"‡∏£‡∏≠‡∏á‡πÄ‡∏ó‡πâ‡∏≤",d:"+SPD",c:200,i:"fa-bolt",cl:"text-yellow-400",act:()=>{player.atkSpeedBase=Math.max(20,player.atkSpeedBase-10);}},
                {n:"‡∏¢‡∏≤",d:"+HP",c:100,i:"fa-heart",cl:"text-green-400",act:()=>{player.hp=Math.min(player.hp+200,player.maxHp);}}
            ];
            grid.innerHTML='';
            items.forEach(it=>{
                const b=document.createElement('button');
                b.className='flex flex-col items-center bg-slate-800 p-2 rounded-xl border-2 border-slate-600 hover:bg-slate-700 active:bg-slate-600 transition justify-between btn-press group shop-card h-24 relative overflow-hidden';
                b.onclick=()=>{ if(STATE.gold>=it.c){ STATE.gold-=it.c; it.act(); updateHud(); AudioSys.buy(); createFloatingText(player.x,player.y,"UPGRADE!","#10b981"); } };
                b.innerHTML=`<div class="text-3xl ${it.cl} drop-shadow-md mt-1"><i class="fas ${it.i}"></i></div><div class="text-[10px] font-bold text-slate-100 uppercase tracking-wide z-10 text-center leading-tight">${it.n}</div><div class="bg-black/60 px-2 rounded text-xs text-yellow-400 font-mono">${it.c}G</div>`;
                grid.appendChild(b);
            });
        }

        function loop(ts) {
            if(!STATE.active)return;
            requestAnimationFrame(loop);
            const now=Date.now();
            if(now-lastSpawn>CONFIG.spawnRate) {
                ['top','mid','bot'].forEach(l=>{ new Minion('blue',l); new Minion('red',l); });
                lastSpawn=now;
            }
            entities.forEach(e=>e.update());
            particles.forEach(p=>p.update());
            entities=entities.filter(e=>{ if(e.type==='hero'||e.type==='tower'||e.type==='base')return true; return !e.dead; });
            particles=particles.filter(p=>p.life>0);
            
            projectiles=projectiles.filter(p=>{
                const dx=p.tx.x-p.x, dy=p.tx.y-p.y, d=Math.hypot(dx,dy);
                if(d<15){ p.tx.takeDamage(p.dmg); return false; }
                const a=Math.atan2(dy,dx); p.x+=Math.cos(a)*p.speed; p.y+=Math.sin(a)*p.speed;
                return true;
            });

            if(redBase.hp<=0) gameOver(true); if(blueBase.hp<=0) gameOver(false);
            updateHud();
            
            // Draw
            ctx.clearRect(0,0,canvas.width,canvas.height);
            ctx.save();
            // Scale and Translate
            ctx.scale(STATE.scale, STATE.scale);
            ctx.translate(-STATE.cam.x, -STATE.cam.y);
            
            // Map
            ctx.fillStyle=ASSETS.colors.grassDark; ctx.fillRect(0,0,CONFIG.mapW,CONFIG.mapH);
            ctx.fillStyle='#064e3b'; ctx.beginPath(); ctx.arc(CONFIG.fountainBlueX,CONFIG.mapH/2,CONFIG.fountainRadius,0,Math.PI*2); ctx.fill();
            ctx.fillStyle='#450a0a'; ctx.beginPath(); ctx.arc(CONFIG.fountainRedX,CONFIG.mapH/2,CONFIG.fountainRadius,0,Math.PI*2); ctx.fill();
            
            ctx.strokeStyle='#64748b'; ctx.lineWidth=140; ctx.lineCap='round';
            const w=CONFIG.mapW, h=CONFIG.mapH, m=200;
            ctx.beginPath(); ctx.moveTo(0,h/2); ctx.lineTo(w,h/2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(200,h/2); ctx.quadraticCurveTo(200,m,m+200,m); ctx.lineTo(w-m-200,m); ctx.quadraticCurveTo(w-200,m,w-200,h/2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(200,h/2); ctx.quadraticCurveTo(200,h-m,m+200,h-m); ctx.lineTo(w-m-200,h-m); ctx.quadraticCurveTo(w-200,h-m,w-200,h/2); ctx.stroke();

            entities.forEach(e=>e.draw(ctx));
            projectiles.forEach(p=>{ ctx.fillStyle=p.color||'yellow'; ctx.beginPath(); ctx.arc(p.x,p.y,5,0,Math.PI*2); ctx.fill(); });
            particles.forEach(p=>p.draw(ctx));
            ctx.restore();

            // Minimap
            mmCtx.fillStyle='#0f172a'; mmCtx.fillRect(0,0,mmCanvas.width,mmCanvas.height);
            mmCtx.strokeStyle='#334155'; mmCtx.lineWidth=2;
            const mw=mmCanvas.width, mh=mmCanvas.height;
            mmCtx.beginPath(); mmCtx.moveTo(0,mh/2); mmCtx.lineTo(mw,mh/2); mmCtx.stroke();
            entities.forEach(e=>{
                if(e.dead)return;
                const mx=e.x*(mw/CONFIG.mapW), my=e.y*(mh/CONFIG.mapH);
                mmCtx.fillStyle=e.team==='blue'?'#3b82f6':'#ef4444';
                if(e.type==='hero'){ mmCtx.fillStyle='#fff'; mmCtx.beginPath(); mmCtx.arc(mx,my,3,0,Math.PI*2); mmCtx.fill(); mmCtx.strokeStyle=e.team==='blue'?'#3b82f6':'#ef4444'; mmCtx.lineWidth=1; mmCtx.stroke(); }
                else if(e.type==='base') mmCtx.fillRect(mx-3,my-3,6,6);
                else if(e.type==='tower') mmCtx.fillRect(mx-2,my-2,4,4);
                else { mmCtx.beginPath(); mmCtx.arc(mx,my,1,0,Math.PI*2); mmCtx.fill(); }
            });
            // Minimap Viewport Rect
            const visW = canvas.width / STATE.scale;
            const visH = canvas.height / STATE.scale;
            const vx=STATE.cam.x*(mw/CONFIG.mapW);
            const vy=STATE.cam.y*(mh/CONFIG.mapH);
            const vw=visW*(mw/CONFIG.mapW);
            const vh=visH*(mh/CONFIG.mapH);
            mmCtx.strokeStyle='#fbbf24'; mmCtx.lineWidth=1; mmCtx.strokeRect(vx,vy,vw,vh);
        }

        // Joystick Event Listeners
        const joystickZone = document.getElementById('joystick-zone');
        const joystickStick = document.getElementById('joystick-stick');
        const joystickBg = document.getElementById('joystick-bg');

        joystickZone.addEventListener('touchstart', (e) => {
            e.preventDefault();
            JOY.active = true;
            JOY.id = e.changedTouches[0].identifier;
            updateJoystick(e.changedTouches[0]);
        });

        joystickZone.addEventListener('touchmove', (e) => {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === JOY.id) {
                    updateJoystick(e.changedTouches[i]);
                    break;
                }
            }
        });

        const endJoystick = (e) => {
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === JOY.id) {
                    JOY.active = false;
                    JOY.dx = 0;
                    JOY.dy = 0;
                    joystickStick.style.transform = `translate(-50%, -50%)`;
                    break;
                }
            }
        };
        joystickZone.addEventListener('touchend', endJoystick);
        joystickZone.addEventListener('touchcancel', endJoystick);

        function updateJoystick(touch) {
            const rect = joystickBg.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            const dx = touch.clientX - centerX;
            const dy = touch.clientY - centerY;
            const distance = Math.min(Math.hypot(dx, dy), rect.width / 2);
            const angle = Math.atan2(dy, dx);
            
            JOY.dx = Math.cos(angle) * (distance / (rect.width/2));
            JOY.dy = Math.sin(angle) * (distance / (rect.width/2));
            
            const stickX = Math.cos(angle) * distance;
            const stickY = Math.sin(angle) * distance;
            
            joystickStick.style.transform = `translate(calc(-50% + ${stickX}px), calc(-50% + ${stickY}px))`;
        }
        
        // Mouse/Touch Events for Tap-to-Move
        canvas.addEventListener('mousedown', (e) => {
            if(!player) return;
            const rect = canvas.getBoundingClientRect();
            // Adjusted world click calculation for Scale
            const worldX = (e.clientX - rect.left) / STATE.scale + STATE.cam.x;
            const worldY = (e.clientY - rect.top) / STATE.scale + STATE.cam.y;
            handleInput(worldX, worldY);
        });
        
        canvas.addEventListener('touchstart', (e) => {
            if(JOY.active) return; // Ignore if using joystick
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            // Adjusted world touch calculation for Scale
            const worldX = (touch.clientX - rect.left) / STATE.scale + STATE.cam.x;
            const worldY = (touch.clientY - rect.top) / STATE.scale + STATE.cam.y;
            handleInput(worldX, worldY);
        });

        function handleInput(worldX, worldY) {
            let clicked = null;
            entities.forEach(ent => {
                if (!ent.dead && Math.hypot(ent.x - worldX, ent.y - worldY) < ent.radius + 15) clicked = ent;
            });

            if (clicked && clicked.team !== player.team) {
                STATE.selectedUnit = clicked;
            } else {
                STATE.target = { x: worldX, y: worldY };
                const marker = document.createElement('div');
                marker.className = 'absolute w-4 h-4 border-2 border-green-400 rounded-full animate-ping pointer-events-none';
                // Marker is DOM based (screen coords)
                // Need to convert back to screen for initial placement? 
                // Or update marker in loop?
                // For simple feedback, calculate screen pos once
                const screenX = (worldX - STATE.cam.x) * STATE.scale;
                const screenY = (worldY - STATE.cam.y) * STATE.scale;
                
                marker.style.left = screenX + 'px';
                marker.style.top = screenY + 'px';
                gameArea.appendChild(marker);
                setTimeout(() => marker.remove(), 500);
            }
        }
        
        mmCanvas.parentElement.addEventListener('mousedown', (e) => {
            if(!STATE.active)return;
            const r = mmCanvas.getBoundingClientRect();
            STATE.target = { x: (e.clientX-r.left)/MM_SCALE_X, y: (e.clientY-r.top)/MM_SCALE_Y };
        });

        function resize() {
            canvas.width = gameArea.clientWidth;
            canvas.height = gameArea.clientHeight;
            const mmRect = mmCanvas.parentElement.getBoundingClientRect();
            mmCanvas.width = mmRect.width;
            mmCanvas.height = mmRect.height;
            MM_SCALE_X = mmCanvas.width / CONFIG.mapW;
            MM_SCALE_Y = mmCanvas.height / CONFIG.mapH;
            
            // --- AUTO SCALING LOGIC ---
            // Goal: Show at least ~800 world units height or ~1200 width depending on aspect
            // If mobile portrait: width is small, we need to zoom out to see side-to-side or clamp?
            // Let's ensure a fixed vertical field of view for consistent gameplay
            // Target visible height: 800 units
            const targetVisibleHeight = 800;
            STATE.scale = canvas.height / targetVisibleHeight;
            
            // Safety clamp for very wide/tall screens
            // Min scale 0.5 (zoom out), Max 1.2 (zoom in)
            STATE.scale = Math.max(0.5, Math.min(1.5, STATE.scale));

            if (!STATE.active && player) {
                draw(); drawMinimap();
            }
        }
        window.addEventListener('resize', resize);
        // Initial resize happens in init/startGame sequence too
        setTimeout(resize, 100);

    </script>
</body>
</html>
