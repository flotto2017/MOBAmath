<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Math ROV: Mobile Edition</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">

  <!-- ‚úÖ UPGRADED UI STYLE (Neon Glass + Glow + FX) -->

  <style>
    :root{
      --bg0:#020617; --bg1:#0b1226;
      --glass: rgba(15,23,42,.62);
      --stroke: rgba(148,163,184,.18);
      --glow: 0 0 22px rgba(59,130,246,.25);
      --glow2: 0 0 26px rgba(34,197,94,.18);
      --shadow: 0 20px 60px rgba(0,0,0,.55);
    }

    body{
      overscroll-behavior:none; user-select:none; -webkit-user-select:none; overflow:hidden;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Tahoma, Geneva, Verdana, sans-serif;
      background: radial-gradient(1200px 600px at 25% 10%, rgba(59,130,246,.20), transparent 55%),
                  radial-gradient(900px 500px at 85% 20%, rgba(34,197,94,.14), transparent 55%),
                  radial-gradient(800px 500px at 55% 90%, rgba(168,85,247,.10), transparent 60%),
                  linear-gradient(180deg, var(--bg0), var(--bg1));
    }

    body::before{
      content:""; position:fixed; inset:-40%;
      background:
        radial-gradient(circle at 10% 20%, rgba(255,255,255,.10) 0 2px, transparent 3px),
        radial-gradient(circle at 70% 30%, rgba(255,255,255,.08) 0 1px, transparent 2px),
        radial-gradient(circle at 30% 80%, rgba(255,255,255,.06) 0 2px, transparent 3px);
      filter: blur(0.2px);
      opacity:.35; pointer-events:none;
      animation: drift 18s linear infinite;
    }
    @keyframes drift{ from{ transform:translate3d(0,0,0) } to{ transform:translate3d(8%,6%,0) } }

    #main-wrapper{
      display:flex; flex-direction:column;
      height:100vh; height:100dvh; width:100vw;
    }

    #game-area{
      flex-grow:1; position:relative; overflow:hidden;
      background:
        radial-gradient(1200px 700px at 30% 40%, rgba(14,165,233,.10), transparent 60%),
        radial-gradient(900px 600px at 70% 55%, rgba(34,197,94,.08), transparent 60%),
        linear-gradient(180deg, rgba(6,78,59,.92), rgba(2,44,34,.92));
      cursor: crosshair; touch-action:none;
    }
    #game-area::after{
      content:""; position:absolute; inset:0;
      border:1px solid rgba(148,163,184,.12);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.25);
      pointer-events:none;
    }

#ui-panel{
  /* ‚úÖ ‡πÄ‡∏î‡∏¥‡∏° fix 138px ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏ö‡∏≤‡∏á‡∏à‡∏≠‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏û‡∏≠ */
  height: auto;
  min-height: 150px;
  max-height: 42vh;                 /* ‚úÖ ‡∏Å‡∏±‡∏ô‡∏Å‡∏¥‡∏ô‡∏à‡∏≠‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ */
  padding-bottom: env(safe-area-inset-bottom, 0px); /* ‚úÖ ‡∏Å‡∏±‡∏ô‡∏ä‡∏ô‡∏Ç‡∏≠‡∏ö‡∏•‡πà‡∏≤‡∏á‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠ */

  background: linear-gradient(180deg, rgba(2,6,23,.25), rgba(2,6,23,.55)),
              radial-gradient(600px 180px at 20% 0%, rgba(59,130,246,.12), transparent 60%),
              radial-gradient(600px 180px at 80% 0%, rgba(34,197,94,.10), transparent 60%);
  border-top: 1px solid rgba(148,163,184,.18);
  display:flex;
  flex-direction:row;
  box-shadow: 0 -18px 60px rgba(0,0,0,.65);
  z-index:50;
  backdrop-filter: blur(10px);

  overflow: hidden;                 /* ‚úÖ ‡∏Å‡∏±‡∏ô‡∏•‡πâ‡∏ô */
}

    .damage-text{
      position:absolute; color:white; font-weight:900; font-size:24px; pointer-events:none;
      animation: floatPop .62s cubic-bezier(.18,.89,.32,1.28) forwards;
      text-shadow: 0 6px 18px rgba(0,0,0,.55);
      z-index:100;
      -webkit-text-stroke: 1.5px rgba(0,0,0,.85);
    }
    @media (min-width: 768px){ .damage-text{ font-size: 38px; } }
    @keyframes floatPop{
      0%   { transform: translateY(0) scale(.55); opacity:0; filter: blur(.6px); }
      18%  { transform: translateY(-12px) scale(1.18); opacity:1; filter: blur(0); }
      100% { transform: translateY(-58px) scale(1); opacity:0; }
    }

    .overlay-screen{
      position:absolute; inset:0; z-index:100;
      background:
        radial-gradient(1200px 700px at 50% 20%, rgba(59,130,246,.18), transparent 60%),
        radial-gradient(900px 600px at 50% 80%, rgba(34,197,94,.10), transparent 60%),
        rgba(0,0,0,.78);
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      backdrop-filter: blur(10px);
    }
    .hidden{ display:none !important; }

    .btn-press{
      transform: translateY(0);
      transition: transform .12s ease, filter .12s ease, box-shadow .12s ease;
    }
    .btn-press:hover{ filter: brightness(1.06); box-shadow: var(--shadow); }
    .btn-press:active{ transform: translateY(2px) scale(.98); filter: brightness(.98); }

    .shop-card{
      border: 1px solid rgba(148,163,184,.18);
      background: rgba(15,23,42,.55);
      box-shadow: 0 10px 28px rgba(0,0,0,.35);
    }
    .shop-card:hover{
      border-color: rgba(59,130,246,.55);
      box-shadow: 0 0 0 1px rgba(59,130,246,.18), 0 18px 46px rgba(0,0,0,.45);
    }
    .shop-card:active{ transform: translateY(2px) scale(.98); }

    ::-webkit-scrollbar{ width:4px; height:4px; }
    ::-webkit-scrollbar-track{ background: rgba(2,6,23,.6); }
    ::-webkit-scrollbar-thumb{ background: rgba(100,116,139,.75); border-radius: 10px; }

    /* JOYSTICK */
    #joystick-zone{
      position:absolute; bottom: 18px; left: 18px;
      width: 132px; height: 132px; z-index: 40;
      display:flex; align-items:center; justify-content:center;
      pointer-events:auto;
      filter: drop-shadow(0 16px 22px rgba(0,0,0,.45));
    }
    #joystick-bg{
      width: 108px; height: 108px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(148,163,184,.25);
      border-radius: 999px; position:relative;
      backdrop-filter: blur(8px);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.25);
    }
    #joystick-bg::after{
      content:""; position:absolute; inset:10px; border-radius:999px;
      border:1px dashed rgba(148,163,184,.18);
    }
    #joystick-stick{
      width: 44px; height: 44px;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.22), rgba(59,130,246,.85));
      border: 2px solid rgba(255,255,255,.75);
      border-radius:999px; position:absolute;
      top:50%; left:50%; transform: translate(-50%, -50%);
      box-shadow: 0 0 24px rgba(59,130,246,.45), inset 0 0 0 1px rgba(0,0,0,.25);
      transition: transform .08s ease;
    }
/* =========================
   RECALL: MOBA SPELL BUTTON
   ========================= */
:root{
  --recallP: 0; /* 0..1 */
}

#btn-recall{
  width: 76px; height: 76px;
  border-radius: 9999px;
  position: absolute;
  bottom: 18px; right: 18px;
  pointer-events: auto;
  user-select: none;
  border: 2px solid rgba(255,255,255,.12);
  background:
    radial-gradient(120px 120px at 30% 20%, rgba(96,165,250,.45), rgba(2,6,23,.9) 55%),
    radial-gradient(120px 120px at 70% 80%, rgba(34,197,94,.22), rgba(2,6,23,.0) 60%);
  box-shadow:
    0 18px 40px rgba(0,0,0,.55),
    inset 0 0 0 1px rgba(148,163,184,.08);
  transform: translateZ(0);
  transition: transform .08s ease, filter .2s ease, box-shadow .2s ease;
}
#btn-recall:active{ transform: scale(.96); }
#btn-recall:hover{ filter: brightness(1.08); }

#btn-recall .spell-core{
  position:absolute; inset: 7px;
  border-radius: 9999px;
  background: radial-gradient(circle at 30% 25%, rgba(255,255,255,.20), rgba(255,255,255,0) 45%),
              radial-gradient(circle at 50% 60%, rgba(59,130,246,.35), rgba(2,6,23,.85) 70%);
  display:flex; flex-direction:column; align-items:center; justify-content:center;
  gap:2px;
}
#btn-recall .spell-ico{ font-size: 22px; line-height: 1; }
#btn-recall .spell-txt{ font-size: 10px; font-weight: 900; letter-spacing: .12em; opacity: .9; }

#btn-recall .spell-ring{
  position:absolute; inset: -4px;
  border-radius: 9999px;
  background: conic-gradient(rgba(59,130,246,.95) calc(var(--recallP)*360deg),
                             rgba(255,255,255,.12) 0);
  -webkit-mask: radial-gradient(circle, transparent 64%, #000 65%);
          mask: radial-gradient(circle, transparent 64%, #000 65%);
  filter: drop-shadow(0 0 10px rgba(59,130,246,.35));
  opacity: .95;
}

#btn-recall.recalling{
  box-shadow:
    0 18px 50px rgba(59,130,246,.22),
    0 0 0 2px rgba(59,130,246,.18),
    inset 0 0 0 1px rgba(148,163,184,.10);
}
#btn-recall.recalling .spell-core{
  animation: recallPulse 1.1s ease-in-out infinite;
}
@keyframes recallPulse{
  0%,100%{ transform: scale(1); filter: saturate(1); }
  50%{ transform: scale(1.03); filter: saturate(1.25); }
}

#btn-recall .spell-hint{
  position:absolute;
  bottom: -16px; left: 50%;
  transform: translateX(-50%);
  font-size: 10px;
  color: rgba(255,255,255,.75);
  background: rgba(0,0,0,.35);
  padding: 2px 8px;
  border-radius: 9999px;
  border: 1px solid rgba(255,255,255,.08);
  backdrop-filter: blur(6px);
  pointer-events:none;
}

/* =========================
   RECALL VFX OVERLAY (Hero)
   ========================= */
.recall-vfx{
  position:absolute;
  width: 220px; height: 220px;
  border-radius: 9999px;
  pointer-events:none;
  transform: translate(-50%, -50%);
  background:
    radial-gradient(circle at 50% 50%, rgba(59,130,246,.22), rgba(59,130,246,0) 58%),
    conic-gradient(from 90deg, rgba(34,197,94,.0), rgba(59,130,246,.55), rgba(34,197,94,.0));
  filter: drop-shadow(0 0 18px rgba(59,130,246,.25));
  animation: vfxSpin 1.2s linear infinite;
  opacity: .9;
}
@keyframes vfxSpin{ to { transform: translate(-50%, -50%) rotate(360deg); } }

.recall-beam{
  position:absolute;
  width: 160px; height: 420px;
  transform: translate(-50%, -100%);
  pointer-events:none;
  background: linear-gradient(to bottom,
    rgba(59,130,246,0),
    rgba(59,130,246,.35),
    rgba(255,255,255,.16),
    rgba(59,130,246,0));
  filter: blur(0.2px) drop-shadow(0 0 18px rgba(59,130,246,.28));
  animation: beamFlicker .9s ease-in-out infinite;
  opacity: .85;
}
@keyframes beamFlicker{
  0%,100%{ opacity: .75; }
  50%{ opacity: .95; }
}
    /* Minimap */
    #minimap-container{
      position:absolute; top: 10px; right: 10px; z-index:60;
      width: 190px; height: 110px;
      background: rgba(2,6,23,.55);
      border:1px solid rgba(148,163,184,.18);
      border-radius: 14px;
      overflow:hidden;
      backdrop-filter: blur(10px);
      box-shadow: 0 14px 40px rgba(0,0,0,.45);
    }

    /* hit flash */
    #hit-flash{
      position:absolute; inset:0; z-index: 65;
      background: radial-gradient(700px 420px at 50% 55%, rgba(239,68,68,.22), transparent 62%);
      opacity:0; pointer-events:none;
      transition: opacity .12s ease;
    }

    /* toast */
    #toast{
      position:absolute; left:50%; top: 12px; transform: translateX(-50%);
      z-index: 80; pointer-events:none;
      padding: 8px 12px;
      background: rgba(2,6,23,.55);
      border: 1px solid rgba(148,163,184,.18);
      border-radius: 999px;
      backdrop-filter: blur(10px);
      box-shadow: 0 18px 50px rgba(0,0,0,.45);
      font-weight:800; letter-spacing:.5px;
      opacity:0; transition: opacity .18s ease, transform .18s ease;
    }
    #toast.show{ opacity:1; transform: translateX(-50%) translateY(0); }
    #toast.ok{
      color: #a7f3d0;
      box-shadow: 0 0 0 1px rgba(34,197,94,.20), 0 18px 50px rgba(0,0,0,.45);
    }
    #toast.bad{
      color: #fecaca;
      box-shadow: 0 0 0 1px rgba(239,68,68,.18), 0 18px 50px rgba(0,0,0,.45);
    }
  </style>

  <!-- FIREBASE MODULE -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, setDoc, onSnapshot, updateDoc, getDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    let firebaseConfig = {
      apiKey: "AIzaSyDSRWRHZ0tSWBolCjtzcz9SHtozIimqXNQ",
      authDomain: "mobamath-d7343.firebaseapp.com",
      projectId: "mobamath-d7343",
      storageBucket: "mobamath-d7343.firebasestorage.app",
      messagingSenderId: "1073634282918",
      appId: "1:1073634282918:web:576aab55ae51ed02a11367",
      measurementId: "G-WVF93G5ZC8"
    };

    const appId = 'math-moba-v1';
    let db, auth, roomId;
    let isHost = false;
    let unsubscribeRoom = null;
    let lastSend = 0;

    async function initFirebase() {
      try {
        const app = initializeApp(firebaseConfig);
        auth = getAuth(app);
        db = getFirestore(app);
        await signInAnonymously(auth);
        onAuthStateChanged(auth, () => {});
        return true;
      } catch (e) {
        console.warn("Firebase Init Failed:", e);
        return false;
      }
    }
    initFirebase();

    window.NetworkAPI = {
      createRoom: async (difficulty) => {
        const currentUser = auth?.currentUser;
        if (!db || !currentUser) { forceOfflineStart(difficulty); return null; }

        try {
          roomId = Math.floor(Math.random() * 9000 + 1000).toString();
          const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', roomId);
          await setDoc(roomRef, {
            host: currentUser.uid,
            guest: null,
            status: 'waiting',
            difficulty: difficulty,
            lastUpdate: Date.now()
          });
          isHost = true;
          window.NetworkAPI.listen(roomId);
          return roomId;
        } catch (e) {
          forceOfflineStart(difficulty);
          return null;
        }
      },
      joinRoom: async (id) => {
        const currentUser = auth?.currentUser;
        if (!db || !currentUser) return false;

        try {
          roomId = id;
          const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', roomId);
          const snap = await getDoc(roomRef);
          if (snap.exists() && snap.data().status === 'waiting') {
            await updateDoc(roomRef, { guest: currentUser.uid, status: 'ready' });
            isHost = false;
            window.NetworkAPI.listen(roomId);
            return true;
          }
          return false;
        } catch (e) { return false; }
      },
      listen: (id) => {
        if (!db || window.STATE?.isOfflineMode) return;
        unsubscribeRoom = onSnapshot(
          doc(db, 'artifacts', appId, 'public', 'data', 'rooms', id),
          (docSnap) => {
            const data = docSnap.data();
            if (data) {
              if (data.difficulty && !isHost) { if (window.setDifficulty) window.setDifficulty(data.difficulty); }
              if (data.status === 'ready' && window.onGameStart) window.onGameStart(isHost ? 'blue' : 'red');
              if (data.hostData && !isHost && window.updateEnemy) window.updateEnemy(data.hostData);
              else if (data.guestData && isHost && window.updateEnemy) window.updateEnemy(data.guestData);
            }
          },
          (error) => {
            if (error.code === 'resource-exhausted') {
              window.STATE.isOfflineMode = true;
              if (unsubscribeRoom) { unsubscribeRoom(); unsubscribeRoom = null; }
              alert("‡πÇ‡∏Ñ‡∏ß‡∏ï‡πâ‡∏≤‡πÄ‡∏ï‡πá‡∏°! ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏•‡πà‡∏ô‡∏Ñ‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß");
            }
          }
        );
      },
      send: async (data) => {
        if (!roomId || !db || !auth?.currentUser || window.STATE?.isOfflineMode) return;
        const now = Date.now();
        if (now - lastSend < 2000) return;
        lastSend = now;

        try {
          const field = isHost ? 'hostData' : 'guestData';
          const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', roomId);
          await updateDoc(roomRef, { [field]: data });
        } catch(e) {
          if (e.code === 'resource-exhausted') window.STATE.isOfflineMode = true;
        }
      },
      cancel: async () => {
        if (unsubscribeRoom) { unsubscribeRoom(); unsubscribeRoom = null; }
        if (isHost && roomId && db && !window.STATE?.isOfflineMode) {
          try { await deleteDoc(doc(db, 'artifacts', appId, 'public', 'data', 'rooms', roomId)); } catch(e) {}
        }
        roomId = null; isHost = false;
      }
    };

    function forceOfflineStart(difficulty) {
      window.STATE.isOfflineMode = true;
      window.STATE.difficulty = difficulty || 'easy';
      document.getElementById('lobby-overlay')?.classList.add('hidden');
      if (window.onGameStart) window.onGameStart('blue');
    }
  </script>
</head>

<body class="flex flex-col h-screen w-screen text-white">
  <div id="main-wrapper" class="flex flex-col h-full w-full">

    <!-- Game Area -->
    <div id="game-area">
      <canvas id="game-canvas" class="block w-full h-full"></canvas>

      <!-- ‚úÖ FX LAYERS -->
      <div id="hit-flash"></div>
      <div id="toast"></div>

      <!-- MINIMAP -->
      <div id="minimap-container">
        <canvas id="minimap-canvas" class="w-full h-full cursor-crosshair"></canvas>
        <div class="absolute bottom-1 left-1 text-[8px] text-white/50 pointer-events-none font-bold bg-black/40 px-1 rounded backdrop-blur-sm">MAP</div>
      </div>

      <!-- Fullscreen -->
      <button onclick="toggleFullScreen()"
        class="absolute top-[128px] left-3 z-50 bg-yellow-500 hover:bg-yellow-400 text-black font-extrabold text-[10px] px-2 py-1 rounded-full shadow border border-yellow-300 pointer-events-auto active:scale-95 transition">
        <i class="fas fa-expand mr-1"></i> FULLSCREEN
      </button>

      <!-- JOYSTICK -->
      <div id="joystick-zone">
        <div id="joystick-bg"><div id="joystick-stick"></div></div>
      </div>

      <!-- MENU -->
      <div id="menu-overlay" class="overlay-screen">
        <h1 class="text-6xl md:text-8xl font-black text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-green-400 mb-8 drop-shadow-lg text-center">
          MATH ROV
        </h1>
        <div class="flex flex-col gap-6 w-96 max-w-[92vw]">
          <button onclick="selectMode('single')"
            class="px-8 py-6 bg-blue-600 hover:bg-blue-500 text-white font-black rounded-2xl text-3xl shadow-xl hover:scale-105 transition-transform border-b-8 border-blue-800 flex items-center justify-center gap-4 btn-press">
            <i class="fas fa-robot"></i> ‡πÄ‡∏•‡πà‡∏ô‡∏Ñ‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
          </button>
          <button onclick="selectMode('multiplayer')"
            class="px-8 py-6 bg-purple-600 hover:bg-purple-500 text-white font-black rounded-2xl text-3xl shadow-xl hover:scale-105 transition-transform border-b-8 border-purple-800 flex items-center justify-center gap-4 btn-press">
            <i class="fas fa-users"></i> ‡πÄ‡∏•‡πà‡∏ô‡∏Å‡∏±‡∏ö‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô
          </button>
        </div>
        <div class="mt-6 text-white/60 text-sm font-bold">
          Tip: ‡∏ï‡∏≠‡∏ö‡∏ñ‡∏π‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ü‡∏≤‡∏£‡πå‡∏°‡∏ó‡∏≠‡∏á ‡πÅ‡∏•‡πâ‡∏ß‡∏ã‡∏∑‡πâ‡∏≠‡πÑ‡∏≠‡πÄ‡∏ó‡∏°‡∏≠‡∏±‡∏õ‡∏™‡πÄ‡∏ï‡∏ï‡∏±‡∏™!
        </div>
      </div>

      <div id="difficulty-overlay" class="overlay-screen hidden">
        <h2 class="text-5xl font-black text-white mb-8 drop-shadow">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏Å</h2>
        <div class="flex flex-col gap-5 w-80 max-w-[92vw]">
          <button onclick="confirmDifficulty('easy')" class="px-6 py-4 bg-green-600 hover:bg-green-500 text-white font-black rounded-xl text-2xl border-b-4 border-green-800 btn-press">‡∏á‡πà‡∏≤‡∏¢ (1-9)</button>
          <button onclick="confirmDifficulty('medium')" class="px-6 py-4 bg-yellow-600 hover:bg-yellow-500 text-white font-black rounded-xl text-2xl border-b-4 border-yellow-800 btn-press">‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á (10-99)</button>
          <button onclick="confirmDifficulty('hard')" class="px-6 py-4 bg-red-600 hover:bg-red-500 text-white font-black rounded-xl text-2xl border-b-4 border-red-800 btn-press">‡∏¢‡∏≤‡∏Å (100-999)</button>
          <button onclick="backToMenu()" class="mt-4 text-xl text-gray-300 hover:text-white underline">‡∏¢‡πâ‡∏≠‡∏ô‡∏Å‡∏•‡∏±‡∏ö</button>
        </div>
      </div>

      <div id="lobby-overlay" class="overlay-screen hidden">
        <h2 class="text-5xl font-black text-purple-200 mb-8 drop-shadow">LOBBY</h2>

        <div id="lobby-menu" class="flex flex-col gap-6 w-96 max-w-[92vw]">
          <button id="btn-create-room" onclick="createRoomWrapper()"
            class="px-6 py-5 bg-indigo-600 hover:bg-indigo-500 text-white font-black rounded-xl text-2xl border-b-4 border-indigo-800 btn-press">
            ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡πâ‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà
          </button>

          <div class="flex gap-2">
            <input type="number" id="join-room-id" placeholder="‡∏£‡∏´‡∏±‡∏™ 4 ‡∏´‡∏•‡∏±‡∏Å"
              class="flex-1 px-4 py-3 rounded-xl text-black text-center font-black border-4 border-indigo-500 text-2xl"
              max="9999">
            <button onclick="joinRoom()"
              class="px-6 py-3 bg-pink-600 hover:bg-pink-500 text-white font-black rounded-xl border-b-4 border-pink-800 text-xl btn-press">
              ‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°
            </button>
          </div>

          <button onclick="backToDifficulty()" class="mt-4 text-xl text-gray-300 hover:text-white underline text-center">‡∏¢‡πâ‡∏≠‡∏ô‡∏Å‡∏•‡∏±‡∏ö</button>
        </div>

        <div id="lobby-waiting" class="hidden flex-col items-center">
          <div class="text-2xl text-gray-200 mb-3">‡∏£‡∏´‡∏±‡∏™‡∏´‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì</div>
          <div id="display-room-id"
            class="text-9xl font-mono font-black text-yellow-400 bg-black/60 px-12 py-8 rounded-3xl border border-yellow-500/40 mb-8 select-all tracking-widest shadow-[0_0_30px_rgba(250,204,21,0.3)]">
            ....
          </div>
          <div class="animate-pulse text-blue-200 mb-8 text-2xl"><i class="fas fa-spinner fa-spin mr-2"></i>‡∏£‡∏≠‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°...</div>
          <button onclick="cancelRoom()" class="px-10 py-4 bg-red-600 hover:bg-red-500 text-white font-black rounded-xl shadow-lg border-b-4 border-red-800 btn-press">
            ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å
          </button>
        </div>
      </div>

      <!-- GAME UI -->
      <div id="game-ui" class="hidden pointer-events-none absolute inset-0">

        <!-- Game Over Overlay (‚úÖ added to avoid missing element errors) -->
        <div id="game-over-overlay" class="overlay-screen hidden">
          <div class="text-center">
            <div id="game-result-title" class="text-7xl md:text-9xl font-black mb-4 text-emerald-300 drop-shadow">VICTORY</div>
            <div class="text-white/70 font-bold text-xl mb-8">‡πÅ‡∏ï‡∏∞ ‚Äú‡πÄ‡∏•‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà‚Äù ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏£‡∏≠‡∏ö‡πÉ‡∏´‡∏°‡πà</div>
            <button onclick="location.reload()"
              class="pointer-events-auto px-10 py-4 rounded-2xl bg-emerald-600 hover:bg-emerald-500 font-black text-2xl border-b-8 border-emerald-800 btn-press">
              ‡πÄ‡∏•‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà
            </button>
          </div>
        </div>

        <div id="death-overlay" class="absolute inset-0 bg-gray-900/70 backdrop-blur-md hidden flex-col items-center justify-center z-50">
          <h2 class="text-7xl md:text-9xl font-black text-red-500 mb-4 drop-shadow-lg">YOU DIED</h2>
          <div class="text-white text-4xl md:text-5xl font-black">
            Respawn: <span id="respawn-timer" class="text-yellow-300 font-mono text-6xl md:text-7xl">10</span>s
          </div>
        </div>

        <button onclick="startPlayerRecall()" id="btn-recall" class="">
  <div class="spell-ring"></div>
  <div class="spell-core">
    <div class="spell-ico"><i class="fas fa-portal-enter"></i></div>
    <div class="spell-txt">RECALL</div>
  </div>
  </button>

        <!-- Player Status -->
        <div class="absolute top-3 left-3 z-20 flex gap-2 pointer-events-none select-none">
          <div class="relative w-20 h-20 md:w-24 md:h-24 rounded-2xl border border-white/10 shadow-2xl overflow-hidden bg-slate-900/60 backdrop-blur">
            <div class="absolute inset-0 flex items-center justify-center text-4xl text-blue-300"><i class="fas fa-user-ninja"></i></div>
            <div class="absolute bottom-0 w-full text-center bg-black/60 text-xs md:text-sm text-white font-black py-1">LV.<span id="hud-level">1</span></div>
          </div>
          <div class="flex flex-col justify-center gap-2 min-w-[170px] md:min-w-[220px]">
            <div class="h-6 bg-black/40 rounded-full border border-white/10 relative overflow-hidden backdrop-blur">
              <div id="hud-hp-bar" class="h-full bg-gradient-to-r from-green-600 to-green-400 w-full transition-all duration-300"></div>
              <span class="absolute inset-0 text-xs md:text-sm text-white flex items-center justify-center font-black drop-shadow-md tracking-wider">
                <i class="fas fa-heart text-red-400 mr-1.5"></i> <span id="hud-hp-text">500/500</span>
              </span>
            </div>
            <div class="grid grid-cols-3 gap-x-2 gap-y-1.5 bg-black/45 p-2 rounded-2xl border border-white/10 backdrop-blur-sm">
              <div class="flex items-center justify-center text-xs md:text-sm text-white font-black"><i class="fas fa-khanda text-red-300 mr-1"></i> <span id="hud-atk">45</span></div>
              <div class="flex items-center justify-center text-xs md:text-sm text-white font-black"><i class="fas fa-shield-alt text-blue-300 mr-1"></i> <span id="hud-armor">0</span></div>
              <div class="flex items-center justify-center text-xs md:text-sm text-white font-black"><i class="fas fa-bolt text-yellow-300 mr-1"></i> <span id="hud-aspd">1.0</span></div>
            </div>
          </div>
        </div>

        <!-- Target Panel -->
        <div id="target-panel"
          class="absolute top-4 left-1/2 transform -translate-x-1/2 z-20 flex gap-3 pointer-events-none select-none transition-opacity duration-200 opacity-0 bg-black/55 backdrop-blur-md p-2 rounded-2xl border border-red-500/30 min-w-[170px] md:min-w-[220px]">
          <div class="relative w-12 h-12 rounded-xl border border-red-500/40 overflow-hidden bg-slate-900/60 shrink-0">
            <div class="absolute inset-0 flex items-center justify-center text-3xl text-red-300"><i id="target-icon" class="fas fa-skull"></i></div>
          </div>
          <div class="flex flex-col justify-center w-full">
            <div class="text-xs md:text-sm text-red-100 font-black uppercase tracking-wider mb-0.5" id="target-name">Enemy</div>
            <div class="h-4 bg-black/45 rounded-full border border-white/10 relative overflow-hidden mb-1">
              <div id="target-hp-bar" class="h-full bg-red-600 w-full transition-all duration-200"></div>
              <div class="absolute inset-0 flex items-center justify-center"><span id="target-hp-text" class="text-[10px] font-black text-white drop-shadow-md"></span></div>
            </div>
            <div class="flex gap-3 text-[10px] md:text-xs text-white font-black">
              <span>ATK: <span id="target-atk" class="text-red-200">10</span></span>
              <span>DEF: <span id="target-armor" class="text-blue-200">0</span></span>
            </div>
          </div>
        </div>

      </div>
    </div>

    <!-- Control Panel -->
    <div id="ui-panel">

      <!-- SHOP -->
      <div class="flex-1 border-r border-white/10 flex flex-col p-2 min-w-0">
        <div class="flex justify-between items-center mb-2 px-1 text-white">
          <h3 class="font-black text-xs flex items-center gap-2">
            <span class="inline-flex w-6 h-6 items-center justify-center rounded-full bg-indigo-500/20 border border-indigo-400/20">
              <i class="fas fa-store text-indigo-300"></i>
            </span>
            ‡∏£‡πâ‡∏≤‡∏ô‡∏Ñ‡πâ‡∏≤
          </h3>
          <span class="text-xs font-black text-yellow-200 font-mono bg-yellow-500/10 px-2 py-1 rounded-full border border-yellow-300/20">
            <i class="fas fa-coins text-yellow-300 mr-1"></i><span id="shop-gold-display">0</span>
          </span>
        </div>
        <div id="shop-grid" class="grid grid-cols-4 gap-2 h-full content-center"></div>
      </div>

      <!-- MATH -->
      <div class="flex-1 flex flex-col p-2 relative overflow-hidden min-w-0">
        <div class="absolute inset-0 opacity-10 pointer-events-none"
          style="background-image: radial-gradient(circle at 20% 30%, rgba(255,255,255,.35) 0 1px, transparent 2px),
                               radial-gradient(circle at 70% 60%, rgba(255,255,255,.25) 0 1px, transparent 2px);">
        </div>

        <div class="flex justify-between items-center mb-2 text-white z-10">
          <h3 class="font-black text-xs md:text-sm text-yellow-200 flex items-center gap-2">
            <span class="inline-flex w-6 h-6 items-center justify-center rounded-full bg-yellow-500/15 border border-yellow-400/20">
              <i class="fas fa-brain text-yellow-200"></i>
            </span>
            Farm Gold
          </h3>
          <span class="text-[10px] font-black bg-yellow-400/15 px-2 py-1 rounded-full text-yellow-200 border border-yellow-400/20">+50G</span>
        </div>

        <div class="flex-grow flex flex-col justify-center gap-2 z-10 h-full">
          <div class="bg-black/45 border border-white/10 rounded-2xl p-2 text-center shadow-inner backdrop-blur">
            <span id="math-q" class="text-xl md:text-2xl font-mono font-black text-white tracking-widest drop-shadow-md">?</span>
          </div>
          <div id="math-options-grid"
     class="grid grid-cols-4 gap-2 auto-rows-fr min-h-[56px] pb-1">
</div>
        </div>
      </div>

    </div>
  </div>

  <script>
function setRecallProgress(p01){
  const btn = document.getElementById('btn-recall');
  if(!btn) return;
  const p = Math.max(0, Math.min(1, p01 || 0));
  btn.style.setProperty('--recallP', p.toString());
}

function setRecallState(active){
  const btn = document.getElementById('btn-recall');
  if(!btn) return;
  btn.classList.toggle('recalling', !!active);
}

function spawnRecallVFX(worldX, worldY){
  // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏≠‡∏ü‡πÄ‡∏ü‡∏Å‡∏ï‡πå‡πÄ‡∏õ‡πá‡∏ô DOM overlay ‡∏ö‡∏ô gameArea (‡∏´‡∏°‡∏∏‡∏ô/‡∏•‡∏≥‡πÅ‡∏™‡∏á)
  const sx = (worldX - STATE.cam.x) * STATE.scale;
  const sy = (worldY - STATE.cam.y) * STATE.scale;

  const vfx = document.createElement('div');
  vfx.className = 'recall-vfx';
  vfx.style.left = sx + 'px';
  vfx.style.top  = sy + 'px';
  gameArea.appendChild(vfx);

  const beam = document.createElement('div');
  beam.className = 'recall-beam';
  beam.style.left = sx + 'px';
  beam.style.top  = sy + 'px';
  gameArea.appendChild(beam);

  return { vfx, beam };
}
    // =========================
    // AUDIO
    // =========================
    const AudioSys = {
      ctx: null,
      init: function() { try { const AC = window.AudioContext||window.webkitAudioContext; if(AC){this.ctx=new AC(); if(this.ctx.state==='suspended')this.ctx.resume();} }catch(e){} },
      playTone: function(f,t,d=0.1,v=0.1) { if(!this.ctx)return; const o=this.ctx.createOscillator(),g=this.ctx.createGain(); o.type=t||'sine'; o.frequency.value=f; g.gain.value=v; g.gain.exponentialRampToValueAtTime(0.01,this.ctx.currentTime+d); o.connect(g); g.connect(this.ctx.destination); o.start(); o.stop(this.ctx.currentTime+d); },
      shoot: function() { this.playTone(600,'square',0.1,0.05); },
      hit: function() { this.playTone(120,'sawtooth',0.12,0.06); },
      coin: function() { this.playTone(1200,'sine',0.1); setTimeout(()=>this.playTone(1800,'sine',0.2),100); },
      buy: function() { this.playTone(420,'sine'); setTimeout(()=>this.playTone(680,'sine'),90); },
      win: function() { if(!this.ctx)return; [300,400,500,600,800].forEach((f,i)=>setTimeout(()=>this.playTone(f,'square',0.5),i*200)); }
    };

    // =========================
    // CONFIG / STATE
    // =========================
    const CONFIG = { mapW: 3800, mapH: 1400, baseHp: 5000, towerHp: 1500, spawnRate: 10000, fountainRadius: 350, fountainBlueX: 100, fountainRedX: 3700 };
    const ASSETS = { colors: { grass: '#064e3b', grassDark: '#022c22' } };

    // Expose STATE globally for firebase module
    window.STATE = { active: false, gold: 200, cam: { x: 0, y: 0 }, target: null, selectedUnit: null, shake: 0, difficulty: 'easy', gameMode: 'single', scale: 1, isOfflineMode: false };
    const STATE = window.STATE;

    const JOY = { active: false, dx: 0, dy: 0, id: null };
    const STAT_CAPS = { minAtkCd: 15, maxArmor: 300, maxSpeed: 10 };

    const canvas = document.getElementById('game-canvas'), ctx = canvas.getContext('2d');
    const gameArea = document.getElementById('game-area');
    const mmCanvas = document.getElementById('minimap-canvas'), mmCtx = mmCanvas.getContext('2d');

    let entities = [], particles = [], projectiles = [];
    let player = null, enemyHero = null, lastSpawn = 0, currAns = 0;
    let MM_SCALE_X = 1, MM_SCALE_Y = 1, pendingMode = 'single';
    let blueBase = null, redBase = null;

    // =========================
    // UI FX (Toast + HitFlash)
    // =========================
    const FX = {
      toastTimer: null,
      toast(msg, type="ok"){
        const el = document.getElementById("toast");
        if(!el) return;
        el.className = "";
        el.id = "toast";
        el.textContent = msg;
        el.classList.add("show");
        el.classList.add(type === "bad" ? "bad" : "ok");
        clearTimeout(this.toastTimer);
        this.toastTimer = setTimeout(()=> el.classList.remove("show"), 720);
      },
      hitFlash(){
        const f = document.getElementById("hit-flash");
        if(!f) return;
        f.style.opacity = "1";
        setTimeout(()=> f.style.opacity = "0", 120);
      }
    };

    // =========================
    // Helpers
    // =========================
    function setText(id, val) { const el = document.getElementById(id); if(el) el.innerText = val; }

    function updateHud() {
      if (!player) return;
      setText('shop-gold-display', STATE.gold);
      setText('hud-atk', Math.round(player.dmg));
      setText('hud-armor', Math.round(player.armor));
      setText('hud-aspd', player.aps);

      const dispHp = isNaN(player.hp) ? 0 : Math.floor(player.hp);
      const dispMaxHp = isNaN(player.maxHp) ? 600 : player.maxHp;
      setText('hud-hp-text', `${dispHp}/${dispMaxHp}`);

      const hpBar = document.getElementById('hud-hp-bar');
      if(hpBar) hpBar.style.width = (dispHp / dispMaxHp * 100) + '%';

      const targetPanel = document.getElementById('target-panel');
      if (targetPanel) {
        if (STATE.selectedUnit && !STATE.selectedUnit.dead) {
          targetPanel.classList.remove('opacity-0');
          const t = STATE.selectedUnit;
          const tHp = isNaN(t.hp) ? 0 : Math.floor(t.hp);
          const tMaxHp = isNaN(t.maxHp) || t.maxHp===0 ? 100 : t.maxHp;
          setText('target-name', t.type.toUpperCase());
          setText('target-hp-text', `${tHp}/${tMaxHp}`);
          const tHpBar = document.getElementById('target-hp-bar');
          if(tHpBar) tHpBar.style.width = (tHp / tMaxHp * 100) + '%';
          setText('target-atk', Math.round(t.dmg || 0));
          setText('target-armor', Math.round(t.armor || 0));

          const icon = document.getElementById('target-icon');
          if(icon) {
            icon.className = '';
            if (t.type === 'base') icon.className = 'fas fa-gem';
            else if (t.type === 'tower') icon.className = 'fas fa-chess-rook';
            else icon.className = 'fas fa-skull';
          }
        } else {
          targetPanel.classList.add('opacity-0');
        }
      }
    }

    function createDamageText(x, y, val, color) {
      if(Math.random()>0.8)return;
      const el=document.createElement('div');
      el.className='damage-text';
      el.style.color=color;
      el.innerText=Math.round(val);
      const sx = (x - STATE.cam.x) * STATE.scale;
      const sy = (y - STATE.cam.y) * STATE.scale;
      if(sx>0&&sx<canvas.width&&sy>0&&sy<canvas.height) {
        el.style.left=sx+'px'; el.style.top=sy+'px';
        gameArea.appendChild(el);
        setTimeout(()=>el.remove(),650);
      }
    }

    function createFloatingText(x, y, text, color) {
      const el=document.createElement('div');
      el.className='damage-text';
      el.style.color=color;
      el.innerText=text;
      el.style.fontSize='30px';
      el.style.zIndex='101';
      const sx = (x - STATE.cam.x) * STATE.scale;
      const sy = (y - STATE.cam.y) * STATE.scale;
      el.style.left=sx+'px';
      el.style.top=(sy-30)+'px';
      gameArea.appendChild(el);
      setTimeout(()=>el.remove(),900);
    }

    function resize() {
      canvas.width = gameArea.clientWidth;
      canvas.height = gameArea.clientHeight;

      const mmRect = mmCanvas.parentElement.getBoundingClientRect();
      mmCanvas.width = mmRect.width;
      mmCanvas.height = mmRect.height;
      MM_SCALE_X = mmCanvas.width / CONFIG.mapW;
      MM_SCALE_Y = mmCanvas.height / CONFIG.mapH;

      const targetVisibleHeight = 800;
      STATE.scale = canvas.height / targetVisibleHeight;
      STATE.scale = Math.max(0.5, Math.min(1.5, STATE.scale));
    }

    function gameOver(win) {
      STATE.active = false;
      AudioSys.win();
      const go = document.getElementById('game-over-overlay');
      const title = document.getElementById('game-result-title');
      if (title) {
        title.innerText = win ? "VICTORY" : "DEFEAT";
        title.className = win
          ? "text-7xl md:text-9xl font-black mb-4 text-emerald-300 drop-shadow"
          : "text-7xl md:text-9xl font-black mb-4 text-gray-300 drop-shadow";
      }
      if (go) { go.classList.remove('hidden'); go.classList.add('flex'); }
    }

    function toggleFullScreen() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(err => { alert(`Error attempting to enable fullscreen: ${err.message}`); });
      } else {
        if (document.exitFullscreen) document.exitFullscreen();
      }
    }

    function startPlayerRecall() {
  if (!player || player.dead) return;

  // ‡∏ñ‡πâ‡∏≤‡∏Å‡∏≥‡∏•‡∏±‡∏á Recall ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ã‡πâ‡∏≥
  if (player.isRecalling) return;

  player.isRecalling = true;
  player.recallTimer = player.maxRecallTime || 180;

  // UI ring ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏ï‡πá‡∏° 100%
  setRecallState(true);
  setRecallProgress(1);

  // ‡∏ú‡∏π‡∏Å VFX ‡πÑ‡∏ß‡πâ‡∏Å‡∏±‡∏ö player (‡∏à‡∏∞‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏∏‡∏Å‡πÄ‡∏ü‡∏£‡∏°‡πÉ‡∏ô Hero.update)
  player._recallVFX = spawnRecallVFX(player.x, player.y);
}
    // =========================
    // GAME ENTITIES
    // =========================
    function createTower(team, x, y) {
      const t = new Entity('tower', team, x, y, 40);
      t.maxHp = 1500; t.hp = 1500; t.dmg = 100; t.range = 350; t.atkSpeedBase = 80; t.armor = 30;
      return t;
    }

    class Entity {
      constructor(type, team, x, y, radius) {
        this.type=type; this.team=team; this.x=x; this.y=y; this.radius=radius;
        this.dead=false; this.maxHp=100; this.hp=100; this.dmg=10; this.armor=0; this.atkSpeedBase=60;
        this.range=100; this.speed=0; this.atkCd=0;
        entities.push(this);
      }
      get aps() { return (60/Math.max(5,this.atkSpeedBase)).toFixed(1); }

      update() {
        if(this.dead)return;
        if(this.atkCd>0)this.atkCd--;
        if(this.speed>0) {
          let sx=0, sy=0;
          entities.forEach(o=>{
            if(o!==this && !o.dead && o.speed>0) {
              const dx=this.x-o.x, dy=this.y-o.y, d=Math.hypot(dx,dy), md=this.radius+o.radius+5;
              if(d<md && d>0.1) { const p=(md-d)/d; sx+=dx*p*0.1; sy+=dy*p*0.1; }
            }
          });
          this.x+=sx; this.y+=sy;
        }

        if(this.speed>0||this.type==='tower'||this.type==='base') {
          let t=this.findTarget();
          if(t) {
            const d=Math.hypot(t.x-this.x, t.y-this.y);
            if(d<=this.range) {
              if(this.atkCd<=0){ this.fire(t); this.atkCd=this.atkSpeedBase; }
            } else if(this.speed>0) {
              if(this!==player && this!==enemyHero) this.moveTowards(t.x, t.y);
            }
          } else if(this.speed>0 && this!==player && this!==enemyHero) {
            this.moveTowards(this.team==='blue'?CONFIG.fountainRedX:CONFIG.fountainBlueX, CONFIG.mapH/2);
          }
        }
      }

      findTarget() {
        let c=null, md=700;
        entities.forEach(e=>{
          if(e.team!==this.team && !e.dead) {
            const d=Math.hypot(e.x-this.x, e.y-this.y);
            let s=d; if(e.type==='hero')s-=200;
            if(s<md) { md=s; c=e; }
          }
        });
        return c;
      }

      moveTowards(tx, ty) {
        const a=Math.atan2(ty-this.y, tx-this.x);
        this.x+=Math.cos(a)*this.speed; this.y+=Math.sin(a)*this.speed;
      }

      fire(t) {
        projectiles.push({x:this.x, y:this.y, tx:t, speed:15, color:this.team==='blue'?'#60a5fa':'#f87171', dmg: this.dmg});
        if(this===player) { AudioSys.shoot(); STATE.selectedUnit=t; }
      }

      takeDamage(amt) {
        if (isNaN(amt)) amt = 0;
        if(this===player && player.isRecalling) { player.cancelRecall(); createFloatingText(player.x,player.y,"Interrupted!","#ef4444"); }
        const dmg = Math.max(1, amt * (100 / (100 + (this.armor||0))));
        this.hp -= dmg;
        if(isNaN(this.hp)) this.hp = 0;

        createDamageText(this.x, this.y, dmg, this.team==='blue'?'#ef4444':'#ffffff');

        if(this.hp<=0) {
          this.hp=0;
          if(this.type==='hero') {
            this.dead=true;
            if(this===player)player.startRespawn();
            else if(this===enemyHero)enemyHero.startRespawn();
          } else this.dead=true;

          if(this.dead && player && this.team!==player.team) {
            let r=30; if(this.type==='hero')r=300; if(this.type==='tower')r=500; if(this.type==='base')r=2000;
            if(r>0) { STATE.gold+=r; updateHud(); createFloatingText(this.x,this.y,`+${r}G`,'#facc15'); AudioSys.coin(); }
          }
          if(STATE.selectedUnit===this) STATE.selectedUnit=null;
        }
      }

      draw(ctx) {
        if(this.dead)return;

        // shadow
        ctx.fillStyle='rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(this.x,this.y+this.radius*0.8,this.radius,this.radius*0.4,0,0,Math.PI*2);
        ctx.fill();

        // team ring
        ctx.strokeStyle = this.team === 'blue' ? '#3b82f6' : '#ef4444';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.stroke();

        // enemy tower/base range hint
        if((this.type==='tower'||this.type==='base') && player && this.team!==player.team) {
          const d=Math.hypot(player.x-this.x, player.y-this.y);
          if(d<this.range+200) {
            ctx.beginPath(); ctx.arc(this.x,this.y,this.range,0,Math.PI*2);
            ctx.strokeStyle='rgba(239,68,68,0.18)'; ctx.lineWidth=1; ctx.setLineDash([10,10]); ctx.stroke(); ctx.setLineDash([]);
          }
        }

        // icon
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        if (this.type === 'hero') {
          ctx.font = '40px sans-serif';
          ctx.fillText(this.team === 'blue' ? 'ü•∑' : 'üëπ', this.x, this.y);
        } else if (this.type === 'minion') {
          ctx.font = '24px sans-serif';
          ctx.fillText(this.team === 'blue' ? '‚öîÔ∏è' : 'ü¶†', this.x, this.y);
        } else if (this.type === 'tower') {
          ctx.font = '900 50px sans-serif';
          ctx.fillStyle = this.team === 'blue' ? '#60a5fa' : '#f87171';
          ctx.fillText('‚ôú', this.x, this.y);
        } else if (this.type === 'base') {
          ctx.font = '60px sans-serif';
          ctx.fillText(this.team === 'blue' ? 'üè∞' : 'üèØ', this.x, this.y);
        }

        // hp bar
        const safeHp = isNaN(this.hp) ? 0 : this.hp;
        const safeMaxHp = isNaN(this.maxHp) || this.maxHp === 0 ? 100 : this.maxHp;
        const barW = 60, barH = 6, barY = this.y - this.radius - 15;

        ctx.fillStyle='rgba(0,0,0,.65)'; ctx.fillRect(this.x - barW/2, barY, barW, barH);
        ctx.fillStyle=this.team==='blue'?'#60a5fa':'#f87171';
        ctx.fillRect(this.x - barW/2, barY, barW * (safeHp/safeMaxHp), barH);

        // player ring
        if(this.type==='hero' && this === player) {
          ctx.strokeStyle = 'rgba(255,255,255,.9)'; ctx.lineWidth = 1;
          ctx.beginPath(); ctx.arc(this.x, this.y, this.radius + 6, 0, Math.PI*2); ctx.stroke();
        }

        // selected ring
        if(STATE.selectedUnit===this) {
          ctx.strokeStyle='#facc15'; ctx.lineWidth=2;
          ctx.beginPath(); ctx.arc(this.x,this.y,this.radius+10,0,Math.PI*2); ctx.stroke();
        }
      }
    }

    class Hero extends Entity {
      constructor(team) {
        super('hero', team, 0, 0, 25);
        this.maxHp=600; this.hp=600; this.dmg=60; this.armor=15; this.range=220; this.speed=6;
        this.isRecalling=false; this.recallTimer=0; this.maxRecallTime=180; this.respawnTimer=0;
        this.lastNetUpdate = 0;
        this.spawn();
      }

      spawn() {
        this.x = this.team==='blue'?CONFIG.fountainBlueX:CONFIG.fountainRedX;
        this.y = CONFIG.mapH/2; this.hp=this.maxHp; this.dead=false;
      }

      startRespawn() {
        this.dead=true; this.respawnTimer=10; this.x=-9999;
        if(this===player) {
          const d = document.getElementById('death-overlay');
          d?.classList.remove('hidden'); d?.classList.add('flex');
          FX.toast("üíÄ ‡πÇ‡∏î‡∏ô‡∏™‡∏≠‡∏¢!", "bad");
        }
      }

      cancelRecall() {
  if (!this.isRecalling) return;
  this.isRecalling = false;
  this.recallTimer = 0;

  // ‡∏õ‡∏¥‡∏î UI
  setRecallState(false);
  setRecallProgress(0);

  // ‡∏•‡∏ö VFX
  if (this._recallVFX) {
    this._recallVFX.vfx?.remove();
    this._recallVFX.beam?.remove();
    this._recallVFX = null;
  }
}

      update() {
        if(this.dead) {
          this.respawnTimer -= 1/60;
          if(this===player) document.getElementById('respawn-timer').innerText=Math.ceil(this.respawnTimer);
          if(this.respawnTimer<=0) {
            this.spawn();
            if(this===player) {
              const d = document.getElementById('death-overlay');
              d?.classList.add('hidden'); d?.classList.remove('flex');
              FX.toast("‚úÖ ‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤‡πÅ‡∏•‡πâ‡∏ß!", "ok");
            }
          }
          return;
        }

        // Enemy AI (single/offline)
        if (this === enemyHero) {
          if(STATE.gameMode === 'single' || STATE.isOfflineMode) {
            if (this.hp < this.maxHp * 0.3) {
              this.moveTowards(CONFIG.fountainRedX, CONFIG.mapH/2);
            } else {
              let t = this.findTarget();
              if (t) {
                const d = Math.hypot(t.x - this.x, t.y - this.y);
                if (d <= this.range) {
                  if (this.atkCd <= 0) { this.fire(t); this.atkCd = this.atkSpeedBase; }
                } else this.moveTowards(t.x, t.y);
              } else this.moveTowards(CONFIG.mapW/2, CONFIG.mapH/2);
            }
          }
        }

        if(this===player) {
          if (this.isRecalling) {
  this.recallTimer--;

  // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï UI progress (‡∏à‡∏≤‡∏Å 1 -> 0)
  const p = (this.recallTimer / this.maxRecallTime);
  setRecallProgress(p);

  // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á VFX ‡πÉ‡∏´‡πâ‡∏ï‡∏≤‡∏°‡∏Æ‡∏µ‡πÇ‡∏£‡πà
  if (this._recallVFX) {
    const sx = (this.x - STATE.cam.x) * STATE.scale;
    const sy = (this.y - STATE.cam.y) * STATE.scale;
    this._recallVFX.vfx.style.left = sx + 'px';
    this._recallVFX.vfx.style.top  = sy + 'px';
    this._recallVFX.beam.style.left = sx + 'px';
    this._recallVFX.beam.style.top  = sy + 'px';
  }

  // ‡∏Ñ‡∏£‡∏ö‡πÄ‡∏ß‡∏•‡∏≤: ‡∏ó‡∏≥‡∏≠‡∏ô‡∏¥‡πÄ‡∏°‡∏ä‡∏±‡∏ô ‚Äú‡∏´‡∏≤‡∏¢‡∏ß‡∏±‡∏ö‚Äù ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏≠‡∏¢‡∏ß‡∏≤‡∏õ
  if (this.recallTimer <= 0) {
    // ‡πÄ‡∏≠‡∏ü‡πÄ‡∏ü‡∏Å‡∏ï‡πå‡∏ï‡∏≠‡∏ô‡∏à‡∏ö
    createFloatingText(this.x, this.y, "RECALLED!", "#60a5fa");
    STATE.shake = 6;

    // ‡∏•‡∏ö VFX
    if (this._recallVFX) {
      this._recallVFX.vfx.remove();
      this._recallVFX.beam.remove();
      this._recallVFX = null;
    }

    // ‡∏õ‡∏¥‡∏î UI
    this.isRecalling = false;
    setRecallState(false);
    setRecallProgress(0);

    // ‡∏ß‡∏≤‡∏õ‡∏Å‡∏•‡∏±‡∏ö‡∏ö‡πâ‡∏≤‡∏ô + ‡∏ü‡∏∑‡πâ‡∏ô‡πÄ‡∏•‡∏∑‡∏≠‡∏î
    this.spawn();
    this.hp = this.maxHp;
    STATE.target = null;
  }
}

          if (JOY.active) {
            const moveX = JOY.dx * this.speed;
            const moveY = JOY.dy * this.speed;
            this.x += moveX;
            this.y += moveY;
            if (this.isRecalling) this.cancelRecall();
            STATE.target = null;
            this.x = Math.max(0, Math.min(this.x, CONFIG.mapW));
            this.y = Math.max(0, Math.min(this.y, CONFIG.mapH));
          } else if(STATE.target) {
            const d=Math.hypot(STATE.target.x-this.x, STATE.target.y-this.y);
            if(d>5) { this.moveTowards(STATE.target.x, STATE.target.y); if(this.isRecalling) this.cancelRecall(); }
            else STATE.target=null;
          }

          if(STATE.gameMode==='multiplayer' && window.NetworkAPI && !STATE.isOfflineMode) {
            const now = Date.now();
            if (now - this.lastNetUpdate > 2000) {
              window.NetworkAPI.send({x:this.x, y:this.y, hp:this.hp, maxHp:this.maxHp});
              this.lastNetUpdate = now;
            }
          }

          const homeX=this.team==='blue'?CONFIG.fountainBlueX:CONFIG.fountainRedX;
          if(Math.hypot(this.x-homeX,this.y-CONFIG.mapH/2)<CONFIG.fountainRadius && this.hp<this.maxHp)
            this.hp=Math.min(this.hp+5, this.maxHp);

          if(STATE.shake>0) STATE.shake*=0.9;
          if(STATE.shake<0.5) STATE.shake=0;

          const visW = canvas.width / STATE.scale;
          const visH = canvas.height / STATE.scale;
          STATE.cam.x = Math.max(0, Math.min(this.x - visW/2, CONFIG.mapW - visW)) + (Math.random()-0.5)*STATE.shake;
          STATE.cam.y = Math.max(0, Math.min(this.y - visH/2, CONFIG.mapH - visH)) + (Math.random()-0.5)*STATE.shake;
        }

        super.update();
      }
    }

    class Minion extends Entity {
      constructor(team, lane) {
        const sx = team==='blue'?150:CONFIG.mapW-150;
        const sy = CONFIG.mapH/2;
        super('minion', team, sx, sy, 12);
        this.lane=lane; this.maxHp=250; this.hp=250; this.dmg=25; this.armor=2; this.range=150; this.speed=2.5; this.wpIdx=0;
        this.waypoints = this.getWp(lane, team);
      }
      getWp(lane, team) {
        const w=CONFIG.mapW, h=CONFIG.mapH, m=200;
        if(team==='blue') {
          if(lane==='mid') return [{x:w-150, y:h/2}];
          if(lane==='top') return [{x:250,y:m}, {x:w-250,y:m}, {x:w-150,y:h/2}];
          if(lane==='bot') return [{x:250,y:h-m}, {x:w-250,y:h-m}, {x:w-150,y:h/2}];
        } else {
          if(lane==='mid') return [{x:150, y:h/2}];
          if(lane==='top') return [{x:w-250,y:m}, {x:250,y:m}, {x:150,y:h/2}];
          if(lane==='bot') return [{x:w-250,y:h-m}, {x:250,y:h-m}, {x:150,y:h/2}];
        }
        return [];
      }
      update() {
        if(this.dead)return;
        if(this.atkCd>0)this.atkCd--;

        if(this.speed>0) {
          let sx=0, sy=0;
          entities.forEach(o=>{
            if(o!==this && !o.dead && o.speed>0) {
              const dx=this.x-o.x, dy=this.y-o.y, d=Math.hypot(dx,dy), md=this.radius+o.radius+5;
              if(d<md && d>0.1) { const p=(md-d)/d; sx+=dx*p*0.1; sy+=dy*p*0.1; }
            }
          });
          this.x+=sx; this.y+=sy;
        }

        let t=this.findTarget();
        if(t && Math.hypot(t.x-this.x, t.y-this.y)<=this.range) {
          if(this.atkCd<=0){ this.fire(t); this.atkCd=this.atkSpeedBase; }
        } else {
          if(this.wpIdx < this.waypoints.length) {
            const wp=this.waypoints[this.wpIdx];
            if(Math.hypot(wp.x-this.x, wp.y-this.y)<20) this.wpIdx++;
            else this.moveTowards(wp.x, wp.y);
          } else {
            this.moveTowards(this.team==='blue'?CONFIG.fountainRedX:CONFIG.fountainBlueX, CONFIG.mapH/2);
          }
        }
      }
    }

    // =========================
    // Important: add hit flash on player damage
    // =========================
    const _takeDamage = Entity.prototype.takeDamage;
    Entity.prototype.takeDamage = function(amt){
      if(this === player){
        FX.hitFlash();
        STATE.shake = Math.max(STATE.shake, 8);
      }
      return _takeDamage.call(this, amt);
    };

    // =========================
    // MENU LOGIC
    // =========================
    function selectMode(m) {
      pendingMode = m;
      document.getElementById('menu-overlay').classList.add('hidden');
      const d = document.getElementById('difficulty-overlay');
      d.classList.remove('hidden'); d.classList.add('flex');
    }

    function confirmDifficulty(d) {
      STATE.difficulty = d;
      document.getElementById('difficulty-overlay').classList.add('hidden');
      if(pendingMode==='single') startGame('blue','single');
      else {
        const l = document.getElementById('lobby-overlay');
        l.classList.remove('hidden'); l.classList.add('flex');
      }
    }

    function backToMenu() {
      document.getElementById('difficulty-overlay').classList.add('hidden');
      document.getElementById('menu-overlay').classList.remove('hidden');
    }

    function backToDifficulty() {
      document.getElementById('lobby-overlay').classList.add('hidden');
      const d = document.getElementById('difficulty-overlay');
      d.classList.remove('hidden'); d.classList.add('flex');
    }

    async function createRoomWrapper() {
      if(window.NetworkAPI) {
        const id = await window.NetworkAPI.createRoom(STATE.difficulty);
        if(id){
          document.getElementById('lobby-menu').classList.add('hidden');
          const w = document.getElementById('lobby-waiting');
          w.classList.remove('hidden'); w.classList.add('flex');
          document.getElementById('display-room-id').innerText = id;
          FX.toast("‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡πâ‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß!", "ok");
        }
      }
    }

    async function joinRoom() {
      if(window.NetworkAPI) {
        const id=document.getElementById('join-room-id').value.trim();
        if(!id) return;
        const s=await window.NetworkAPI.joinRoom(id);
        if(s){
          document.getElementById('lobby-overlay').classList.add('hidden');
          FX.toast("üéÆ ‡πÄ‡∏Ç‡πâ‡∏≤‡∏´‡πâ‡∏≠‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!", "ok");
        } else {
          alert("Not Found");
          FX.toast("‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏´‡πâ‡∏≠‡∏á", "bad");
        }
      }
    }

    function cancelRoom() {
      if(window.NetworkAPI && window.NetworkAPI.cancel) window.NetworkAPI.cancel();
      document.getElementById('lobby-waiting').classList.add('hidden');
      document.getElementById('lobby-waiting').classList.remove('flex');
      document.getElementById('lobby-menu').classList.remove('hidden');
      FX.toast("‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡πÅ‡∏•‡πâ‡∏ß", "bad");
    }

    window.onGameStart = (t) => {
      if(STATE.active) return;
      document.getElementById('lobby-overlay')?.classList.add('hidden');
      startGame(t,'multiplayer');
    };
    window.setDifficulty = (d) => { STATE.difficulty = d; };
    window.updateEnemy = (d) => { if(enemyHero && d){ enemyHero.x=d.x; enemyHero.y=d.y; enemyHero.hp=d.hp; enemyHero.maxHp=d.maxHp; } };

    // =========================
    // GAME START / SPAWNS
    // =========================
    function startGame(team, mode) {
      STATE.gameMode = mode; STATE.active = true; AudioSys.init();

      document.getElementById('menu-overlay').classList.add('hidden');
      document.getElementById('game-ui').classList.remove('hidden');

      entities = []; particles = []; projectiles = [];
      STATE.gold = 200; STATE.selectedUnit = null; STATE.target = null; STATE.shake = 0;

      blueBase = new Entity('base','blue',250,CONFIG.mapH/2,70);
      blueBase.maxHp=CONFIG.baseHp; blueBase.hp=blueBase.maxHp; blueBase.armor=60; blueBase.dmg=300; blueBase.range=450;

      redBase = new Entity('base','red',CONFIG.mapW-250,CONFIG.mapH/2,70);
      redBase.maxHp=CONFIG.baseHp; redBase.hp=redBase.maxHp; redBase.armor=60; redBase.dmg=300; redBase.range=450;

      spawnTowers();
      player = new Hero(team);
      enemyHero = new Hero(team==='blue'?'red':'blue');

      resize();
      generateShop();
      newMath();
      loop(performance.now());

      FX.toast("üî• ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°!", "ok");
    }

    function spawnTowers() {
      const w=CONFIG.mapW, h=CONFIG.mapH, m=200;
      createTower('blue', 1500, h/2); createTower('blue', 900, h/2);
      createTower('red', w-1500, h/2); createTower('red', w-900, h/2);

      createTower('blue', 1500, m); createTower('blue', 900, m);
      createTower('red', w-1500, m); createTower('red', w-900, m);

      createTower('blue', 1500, h-m); createTower('blue', 900, h-m);
      createTower('red', w-1500, h-m); createTower('red', w-900, h-m);
    }

    // =========================
    // MATH SYSTEM (‚úÖ with better feedback)
    // =========================
    function newMath() {
      const op=Math.random()>0.5?'+':'-';
      let min=1, max=9;
      if(STATE.difficulty==='medium'){min=10;max=99;}
      if(STATE.difficulty==='hard'){min=100;max=999;}

      currAns = Math.floor(Math.random()*(max-min+1))+min;

      let a, b;
      if(op==='+') { a=Math.floor(Math.random()*currAns); b=currAns-a; }
      else { b=Math.floor(Math.random()*currAns); a=currAns+b; }

      document.getElementById('math-q').innerText = `${a} ${op} ${b} = ?`;

      const grid=document.getElementById('math-options-grid');
      grid.innerHTML='';

      let opts=[currAns];
      for(let i=0;i<20;i++) {
        if(opts.length>=4)break;
        let f=currAns+Math.floor(Math.random()*20)-10;
        if(!opts.includes(f)&&f>=0)opts.push(f);
      }
      opts.sort(()=>Math.random()-0.5).forEach(o=>{
        const btn=document.createElement('button');
        const smallH = window.innerHeight < 760; // ‚úÖ ‡∏õ‡∏£‡∏±‡∏ö threshold ‡πÑ‡∏î‡πâ
btn.className =
  'bg-slate-900/50 hover:bg-slate-900/70 text-white font-black rounded-2xl ' +
  (smallH ? 'text-base py-2' : 'text-lg md:text-2xl py-3') +
  ' border border-white/10 active:translate-y-0.5 transition-all shadow btn-press backdrop-blur';
        btn.innerText=o;

        btn.onclick=()=> {
          if(o===currAns){
            STATE.gold += 50; updateHud();
            AudioSys.coin();
            FX.toast("+50G ‚úÖ ‡πÄ‡∏¢‡∏µ‡πà‡∏¢‡∏°!", "ok");
            newMath();
          } else {
            AudioSys.hit();
            FX.toast("‚ùå ‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà!", "bad");
            btn.classList.add('!bg-red-600/70');
            STATE.shake = Math.max(STATE.shake, 10);
            setTimeout(newMath, 450);
          }
        };
        grid.appendChild(btn);
      });
    }

    // =========================
    // SHOP
    // =========================
    function generateShop() {
      const grid=document.getElementById('shop-grid');
      const items=[
        {n:"‡∏î‡∏≤‡∏ö",d:"+20 ATK",c:200,i:"fa-khanda",cl:"text-red-300",act:()=>{player.dmg+=20;}},
        {n:"‡πÄ‡∏Å‡∏£‡∏≤‡∏∞",d:"+20 DEF",c:200,i:"fa-shield-alt",cl:"text-blue-300",act:()=>{player.armor=Math.min(STAT_CAPS.maxArmor, player.armor+20);}},
        {n:"‡∏°‡∏µ‡∏î‡∏™‡∏≤‡∏¢‡∏ü‡πâ‡∏≤",d:"+ASPD",c:200,i:"fa-bolt",cl:"text-yellow-300",act:()=>{player.atkSpeedBase=Math.max(STAT_CAPS.minAtkCd,player.atkSpeedBase-10);}},
        {n:"‡∏û‡∏•‡∏±‡∏á‡∏ä‡∏µ‡∏ß‡∏¥‡∏ï",d:"+200 MaxHP",c:300,i:"fa-heart",cl:"text-green-300",act:()=>{player.maxHp+=200; player.hp+=200;}}
      ];
      grid.innerHTML='';
      items.forEach(it=>{
        const b=document.createElement('button');
        b.className='flex flex-col items-center p-2 rounded-2xl transition justify-between btn-press shop-card h-20 relative overflow-hidden group';
        b.onclick=()=>{
          if(!player) return;
          if(STATE.gold>=it.c){
            STATE.gold-=it.c;
            it.act();
            updateHud();
            AudioSys.buy();
            createFloatingText(player.x,player.y,"UPGRADE!","#10b981");
            FX.toast("üõí ‡∏ã‡∏∑‡πâ‡∏≠‡πÑ‡∏≠‡πÄ‡∏ó‡∏°‡πÅ‡∏•‡πâ‡∏ß!", "ok");
          } else {
            FX.toast("‡∏ó‡∏≠‡∏á‡πÑ‡∏°‡πà‡∏û‡∏≠!", "bad");
          }
        };
        b.innerHTML=`
          <div class="text-2xl ${it.cl} drop-shadow-md mt-0.5"><i class="fas ${it.i}"></i></div>
          <div class="text-[9px] font-black text-slate-50 uppercase tracking-wide z-10 text-center leading-tight">${it.n}</div>
          <div class="bg-black/40 px-2 py-0.5 rounded-full text-[10px] text-yellow-200 font-mono border border-yellow-300/10">${it.c}G</div>
        `;
        grid.appendChild(b);
      });
    }

    // =========================
    // MAIN LOOP + DRAW
    // =========================
    function loop(ts) {
      if(!STATE.active) return;
      requestAnimationFrame(loop);

      const now=Date.now();
      if(now-lastSpawn>CONFIG.spawnRate) {
        ['top','mid','bot'].forEach(l=>{ new Minion('blue',l); new Minion('red',l); });
        lastSpawn=now;
      }

      entities.forEach(e=>e.update());

      entities=entities.filter(e=>{
        if(e.type==='hero'||e.type==='tower'||e.type==='base')return true;
        return !e.dead;
      });

      projectiles=projectiles.filter(p=>{
        const dx=p.tx.x-p.x, dy=p.tx.y-p.y, d=Math.hypot(dx,dy);
        if(d<15){ p.tx.takeDamage(p.dmg); return false; }
        const a=Math.atan2(dy,dx); p.x+=Math.cos(a)*p.speed; p.y+=Math.sin(a)*p.speed;
        return true;
      });

      if(redBase.hp<=0) gameOver(true);
      if(blueBase.hp<=0) gameOver(false);

      updateHud();

      // draw
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.save();
      ctx.scale(STATE.scale, STATE.scale);
      ctx.translate(-STATE.cam.x, -STATE.cam.y);

      // map base
      ctx.fillStyle=ASSETS.colors.grassDark; ctx.fillRect(0,0,CONFIG.mapW,CONFIG.mapH);
      ctx.fillStyle='#064e3b'; ctx.beginPath(); ctx.arc(CONFIG.fountainBlueX,CONFIG.mapH/2,CONFIG.fountainRadius,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#450a0a'; ctx.beginPath(); ctx.arc(CONFIG.fountainRedX,CONFIG.mapH/2,CONFIG.fountainRadius,0,Math.PI*2); ctx.fill();

      // lanes
      ctx.strokeStyle='rgba(100,116,139,.85)'; ctx.lineWidth=140; ctx.lineCap='round';
      const w=CONFIG.mapW, h=CONFIG.mapH, m=200;

      ctx.beginPath(); ctx.moveTo(0,h/2); ctx.lineTo(w,h/2); ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(200,h/2);
      ctx.quadraticCurveTo(200,m,m+200,m);
      ctx.lineTo(w-m-200,m);
      ctx.quadraticCurveTo(w-200,m,w-200,h/2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(200,h/2);
      ctx.quadraticCurveTo(200,h-m,m+200,h-m);
      ctx.lineTo(w-m-200,h-m);
      ctx.quadraticCurveTo(w-200,h-m,w-200,h/2);
      ctx.stroke();

      entities.forEach(e=>e.draw(ctx));
      projectiles.forEach(p=>{ ctx.fillStyle=p.color||'yellow'; ctx.beginPath(); ctx.arc(p.x,p.y,5,0,Math.PI*2); ctx.fill(); });

      ctx.restore();

      // minimap
      mmCtx.fillStyle='rgba(2,6,23,.85)'; mmCtx.fillRect(0,0,mmCanvas.width,mmCanvas.height);
      mmCtx.strokeStyle='rgba(148,163,184,.25)'; mmCtx.lineWidth=2;
      const mw=mmCanvas.width, mh=mmCanvas.height;

      mmCtx.beginPath(); mmCtx.moveTo(0,mh/2); mmCtx.lineTo(mw,mh/2); mmCtx.stroke();

      entities.forEach(e=>{
        if(e.dead)return;
        const mx=e.x*(mw/CONFIG.mapW), my=e.y*(mh/CONFIG.mapH);
        mmCtx.fillStyle=e.team==='blue'?'#3b82f6':'#ef4444';

        if(e.type==='hero'){
          mmCtx.fillStyle='#fff';
          mmCtx.beginPath(); mmCtx.arc(mx,my,3,0,Math.PI*2); mmCtx.fill();
          mmCtx.strokeStyle=e.team==='blue'?'#3b82f6':'#ef4444'; mmCtx.lineWidth=1; mmCtx.stroke();
        } else if(e.type==='base') {
          mmCtx.fillRect(mx-3,my-3,6,6);
        } else if(e.type==='tower') {
          mmCtx.fillRect(mx-2,my-2,4,4);
        } else {
          mmCtx.beginPath(); mmCtx.arc(mx,my,1,0,Math.PI*2); mmCtx.fill();
        }
      });

      const vx=STATE.cam.x*(mw/CONFIG.mapW), vy=STATE.cam.y*(mh/CONFIG.mapH),
            vw=(canvas.width/STATE.scale)*(mw/CONFIG.mapW), vh=(canvas.height/STATE.scale)*(mh/CONFIG.mapH);
      mmCtx.strokeStyle='#fbbf24'; mmCtx.lineWidth=1; mmCtx.strokeRect(vx,vy,vw,vh);
    }

    // =========================
    // INPUT: Joystick + Tap
    // =========================
    const joystickZone = document.getElementById('joystick-zone');
    const joystickStick = document.getElementById('joystick-stick');
    const joystickBg = document.getElementById('joystick-bg');

    joystickZone.addEventListener('touchstart', (e) => {
      e.preventDefault();
      JOY.active = true;
      JOY.id = e.changedTouches[0].identifier;
      updateJoystick(e.changedTouches[0]);
    }, {passive:false});

    joystickZone.addEventListener('touchmove', (e) => {
      e.preventDefault();
      for (let i = 0; i < e.changedTouches.length; i++) {
        if (e.changedTouches[i].identifier === JOY.id) {
          updateJoystick(e.changedTouches[i]);
          break;
        }
      }
    }, {passive:false});

    const endJoystick = (e) => {
      for (let i = 0; i < e.changedTouches.length; i++) {
        if (e.changedTouches[i].identifier === JOY.id) {
          JOY.active = false;
          JOY.dx = 0; JOY.dy = 0;
          joystickStick.style.transform = `translate(-50%, -50%)`;
          break;
        }
      }
    };
    joystickZone.addEventListener('touchend', endJoystick);
    joystickZone.addEventListener('touchcancel', endJoystick);

    function updateJoystick(touch) {
      const rect = joystickBg.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;

      const dx = touch.clientX - centerX;
      const dy = touch.clientY - centerY;
      const distance = Math.min(Math.hypot(dx, dy), rect.width / 2);
      const angle = Math.atan2(dy, dx);

      JOY.dx = Math.cos(angle) * (distance / (rect.width/2));
      JOY.dy = Math.sin(angle) * (distance / (rect.width/2));

      const stickX = Math.cos(angle) * distance;
      const stickY = Math.sin(angle) * distance;

      joystickStick.style.transform = `translate(calc(-50% + ${stickX}px), calc(-50% + ${stickY}px))`;
    }

    canvas.addEventListener('mousedown', (e) => {
      if(!player) return;
      const rect = canvas.getBoundingClientRect();
      const worldX = (e.clientX - rect.left) / STATE.scale + STATE.cam.x;
      const worldY = (e.clientY - rect.top) / STATE.scale + STATE.cam.y;
      handleInput(worldX, worldY);
    });

    canvas.addEventListener('touchstart', (e) => {
      if(JOY.active) return;
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      const worldX = (touch.clientX - rect.left) / STATE.scale + STATE.cam.x;
      const worldY = (touch.clientY - rect.top) / STATE.scale + STATE.cam.y;
      handleInput(worldX, worldY);
    }, {passive:true});

    function handleInput(worldX, worldY) {
      let clicked = null;
      entities.forEach(ent => {
        if (!ent.dead && Math.hypot(ent.x - worldX, ent.y - worldY) < ent.radius + 15) clicked = ent;
      });

      if (clicked && clicked.team !== player.team) {
        STATE.selectedUnit = clicked;
        FX.toast("üéØ ‡∏•‡πá‡∏≠‡∏Ñ‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢!", "ok");
      } else {
        STATE.target = { x: worldX, y: worldY };
        const marker = document.createElement('div');
        marker.className = 'absolute w-4 h-4 border-2 border-green-300/90 rounded-full animate-ping pointer-events-none';
        const screenX = (worldX - STATE.cam.x) * STATE.scale;
        const screenY = (worldY - STATE.cam.y) * STATE.scale;
        marker.style.left = screenX + 'px';
        marker.style.top = screenY + 'px';
        gameArea.appendChild(marker);
        setTimeout(() => marker.remove(), 520);
      }
    }

    mmCanvas.parentElement.addEventListener('mousedown', (e) => {
      if(!STATE.active) return;
      const r = mmCanvas.getBoundingClientRect();
      STATE.target = { x: (e.clientX-r.left)/MM_SCALE_X, y: (e.clientY-r.top)/MM_SCALE_Y };
    });

    // =========================
    // INIT
    // =========================
    window.addEventListener('resize', resize);
    setTimeout(()=>{ resize(); }, 80);

    // expose functions
    window.startGame = startGame;
    window.createRoomWrapper = createRoomWrapper;
    window.joinRoom = joinRoom;
    window.cancelRoom = cancelRoom;
    window.selectMode = selectMode;
    window.confirmDifficulty = confirmDifficulty;
    window.backToMenu = backToMenu;
    window.backToDifficulty = backToDifficulty;
    window.toggleFullScreen = toggleFullScreen;
    window.startPlayerRecall = startPlayerRecall;
  </script>
</body>
</html>
